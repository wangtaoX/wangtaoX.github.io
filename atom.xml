<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>奔跑的蚂蚁</title>
 <link href="http://wangtaox.github.io/atom.xml" rel="self"/>
 <link href="http://wangtaox.github.io"/>
 <updated>2016-11-17T16:42:17+08:00</updated>
 <id>http://wangtaox.github.io/</id>
 <author>
   <name>TaoWang</name>
 </author>

 
 <entry>
   <title>内核选项tcp_tw_recycle原理</title>
   <link href="http://wangtaox.github.io/2016/10/14/tcp-tw-recycle.html"/>
   <updated>2016-10-14T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/10/14/tcp-tw-recycle</id>
   <content type="html">&lt;h3&gt;why TIME_WAIT state ？&lt;/h3&gt;

&lt;p&gt;在TCP状态机中，TIME_WAIT状态主要用来避免延迟的旧连接的数据被相同的新连接(连接相同指SRC IP:PORT DST IP:PORT相同)所接收。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/fig1.gif&quot; alt=&quot;time_wait&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;连接&amp;lt;(IP a : Port p) - (IP b : Port q)&gt;断开&lt;/li&gt;
&lt;li&gt;新连接&amp;lt;(IP a : Port p) - (IP b : Port q)&gt;建立&lt;/li&gt;
&lt;li&gt;上次断开连接的数据在网络中延迟并在新连接建立后到来，这样的数据应该是错误并被避免的&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;TIME_WAIT状态就是来解决上面这样的问题的，一般TIME_WAIT状态等待的时间等于2MSL(最大报文存活时间的2倍)，这样就可以确保旧的延迟的报文不被新连接所接收到。&lt;/p&gt;

&lt;p&gt;在Linux具体实现协议栈时，TIME_WAIT状态是保存在每个连接相关的数据(结构TCB即TCP control block，保存该连接所有的状态数据)中的，因此在一些高性能的服务器上，就希望这样的TIME_WAIT状态可以尽量的少(节省服务器内存，并且可以快速的端口重用以建立新连接)，所以&lt;a href=&quot;https://tools.ietf.org/html/rfc6191#page-3&quot;&gt;RFC6191&lt;/a&gt;提出了一种基于TCP timestamp的方法来进行快速的TIME_WAIT状态回收。&lt;/p&gt;

&lt;p&gt;RFC6191在思路上借鉴了RFC1122，对比RFC1122通过序列号的递增性，RFC6191则通过TCP timestamp来进行快速的TIME_WAIT状态回收，具体思路大致是当一个新连接(SRC IP, SRC PORT, DST IP, DST PORT)到来时，如果有相同的连接处于TIME_WAIT状态，且新连接的SYN报文的timestamp要大于最近该连接上的timestamp时，可以接受该连接建立的请求。即要求了来自同一个连接(4元组)的timestamp是单调递增的。&lt;/p&gt;

&lt;h3&gt;tcp_tw_recycle内核实现&lt;/h3&gt;

&lt;p&gt;在内核中，当开启了tcp_tw_recycle选项时，即:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;$ echo 1 &amp;gt; /proc/sys/net/ipv4/tcp_tw_recycle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;内核TCP连接建立时函数(未贴完):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;1440 int tcp_v4_conn_request(struct sock *sk, struct sk_buff *skb)
1441 {
1442         struct tcp_options_received tmp_opt;
1443         struct request_sock *req;
1444         struct inet_request_sock *ireq;
1445         struct tcp_sock *tp = tcp_sk(sk);
1446         struct dst_entry *dst = NULL;
1447         __be32 saddr = ip_hdr(skb)-&amp;gt;saddr;
1448         __be32 daddr = ip_hdr(skb)-&amp;gt;daddr;
1449         __u32 isn = TCP_SKB_CB(skb)-&amp;gt;when;
1450         bool want_cookie = false;
1451         struct flowi4 fl4;
1452         struct tcp_fastopen_cookie foc = { .len = -1 };
1453         struct tcp_fastopen_cookie valid_foc = { .len = -1 };
1454         struct sk_buff *skb_synack;
1455         int do_fastopen;
1456
1457         /* Never answer to SYNs send to broadcast or multicast */
1458         if (skb_rtable(skb)-&amp;gt;rt_flags &amp;amp; (RTCF_BROADCAST | RTCF_MULTICAST))
1459                 goto drop;
1460
1461         /* TW buckets are converted to open requests without
1462  * limitations, they conserve resources and peer is
1463  * evidently real one.
1464  */
1465         if (inet_csk_reqsk_queue_is_full(sk) &amp;amp;&amp;amp; !isn) {
1466                 want_cookie = tcp_syn_flood_action(sk, skb, &quot;TCP&quot;);
1467                 if (!want_cookie)
1468                         goto drop;
1469         }
1470
1471         /* Accept backlog is full. If we have already queued enough
1472  * of warm entries in syn queue, drop request. It is better than
1473  * clogging syn queue with openreqs with exponentially increasing
1474  * timeout.
1475  */
1476         if (sk_acceptq_is_full(sk) &amp;amp;&amp;amp; inet_csk_reqsk_queue_young(sk) &amp;gt; 1) {
1477                 NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
1478                 goto drop;
1479         }
1480
1481         req = inet_reqsk_alloc(&amp;amp;tcp_request_sock_ops);
1482         if (!req)
1483                 goto drop;
1484
1485 #ifdef CONFIG_TCP_MD5SIG
1486         tcp_rsk(req)-&amp;gt;af_specific = &amp;amp;tcp_request_sock_ipv4_ops;
1487 #endif
1488
1489         tcp_clear_options(&amp;amp;tmp_opt);
1490         tmp_opt.mss_clamp = TCP_MSS_DEFAULT;
1491         tmp_opt.user_mss  = tp-&amp;gt;rx_opt.user_mss;
1492         tcp_parse_options(skb, &amp;amp;tmp_opt, 0, want_cookie ? NULL : &amp;amp;foc);
1493
1494         if (want_cookie &amp;amp;&amp;amp; !tmp_opt.saw_tstamp)
1495                 tcp_clear_options(&amp;amp;tmp_opt);
1496
1497         tmp_opt.tstamp_ok = tmp_opt.saw_tstamp;
1498         tcp_openreq_init(req, &amp;amp;tmp_opt, skb);
1499
1500         ireq = inet_rsk(req);
1501         ireq-&amp;gt;loc_addr = daddr;
1502         ireq-&amp;gt;rmt_addr = saddr;
1503         ireq-&amp;gt;no_srccheck = inet_sk(sk)-&amp;gt;transparent;
1504         ireq-&amp;gt;opt = tcp_v4_save_options(skb);
1505
1506         if (security_inet_conn_request(sk, skb, req))
1507                 goto drop_and_free;
1508
1509         if (!want_cookie || tmp_opt.tstamp_ok)
1510                 TCP_ECN_create_request(req, skb, sock_net(sk));
1511
1512         if (want_cookie) {
1513                 isn = cookie_v4_init_sequence(sk, skb, &amp;amp;req-&amp;gt;mss);
1514                 req-&amp;gt;cookie_ts = tmp_opt.tstamp_ok;
1515         } else if (!isn) {
1516                 /* VJ&#39;s idea. We save last timestamp seen
1517  * from the destination in peer table, when entering
1518  * state TIME-WAIT, and check against it before
1519  * accepting new connection request.
1520  *
1521  * If &quot;isn&quot; is not zero, this request hit alive
1522  * timewait bucket, so that all the necessary checks
1523  * are made in the function processing timewait state.
1524  */
1525                 if (tmp_opt.saw_tstamp &amp;amp;&amp;amp;
1526                     tcp_death_row.sysctl_tw_recycle &amp;amp;&amp;amp;
1527                     (dst = inet_csk_route_req(sk, &amp;amp;fl4, req)) != NULL &amp;amp;&amp;amp;
1528                     fl4.daddr == saddr) {
1529                         if (!tcp_peer_is_proven(req, dst, true)) {
1530                                 NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_PAWSPASSIVEREJECTED);
1531                                 goto drop_and_release;
1532                         }
1533                 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出在1525行条件判断处，开启TCP_TW_RECYCLE时，会进入函数tcp_peer_is_proven，即判断时间戳的递增性，该函数代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;536 bool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst, bool paws_check)
537 {
538         struct tcp_metrics_block *tm;
539         bool ret;
540
541         if (!dst)
542                 return false;
543
544         rcu_read_lock();
545         tm = __tcp_get_metrics_req(req, dst);
546         if (paws_check) {
547                 if (tm &amp;amp;&amp;amp;
548                     (u32)get_seconds() - tm-&amp;gt;tcpm_ts_stamp &amp;lt; TCP_PAWS_MSL &amp;amp;&amp;amp;
549                     (s32)(tm-&amp;gt;tcpm_ts - req-&amp;gt;ts_recent) &amp;gt; TCP_PAWS_WINDOW)
550                         ret = false;
551                 else
552                         ret = true;
553         } else {
554                 if (tm &amp;amp;&amp;amp; tcp_metric_get(tm, TCP_METRIC_RTT) &amp;amp;&amp;amp; tm-&amp;gt;tcpm_ts_stamp)
555                         ret = true;
556                 else
557                         ret = false;
558         }
559         rcu_read_unlock();
560
561         return ret;
562 }
563 EXPORT_SYMBOL_GPL(tcp_peer_is_proven);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在549行 (s32)(tm-&gt;tcpm_ts - req-&gt;ts_recent) &gt; TCP_PAWS_WINDOW) 即为当前时间小于最近该连接上的时间戳(这个时间戳内核会记录的)，然后返回了false，连接建立就会失败。&lt;/p&gt;

&lt;h3&gt;NAT 与 tcp_tw_recycle&lt;/h3&gt;

&lt;p&gt;当连接通过NAT机器转换到达开启了TCP_TW_RECYCLE的机器上时，由于NAT机器在做转换时并不会修改协议中的时间戳，因此来自不同机器的请求的时间戳不一定是单调递增的，根据上述原理，所以就会出现连接建立失败的情况。&lt;/p&gt;

&lt;p&gt;所以一般机器都是关闭了该选项的，以避免出现连接建立失败的情况。&lt;/p&gt;

&lt;h3&gt;参考资料&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/&quot;&gt;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1122#section-4.2.2.13&quot;&gt;https://tools.ietf.org/html/rfc1122#section-4.2.2.13&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6191#page-3&quot;&gt;https://tools.ietf.org/html/rfc6191#page-3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/lulu/p/4149312.html&quot;&gt;http://www.cnblogs.com/lulu/p/4149312.html&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>React higher order component</title>
   <link href="http://wangtaox.github.io/2016/09/26/react-hoc.html"/>
   <updated>2016-09-26T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/09/26/react-hoc</id>
   <content type="html">&lt;h3&gt;什么是Higher Order Component ?&lt;/h3&gt;

&lt;p&gt;HOC(Higher Order Component)主要用来封装(增强)其它组件，即一个组件封装了另外一个组件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const MyComponent = (props) =&amp;gt; {}
   if (props.data) {
       return (
            &amp;lt;h1&amp;gt;Waiting&amp;lt;/h1&amp;gt;
       );
   }

   return &amp;lt;div&amp;gt;{props.data}&amp;lt;/div&amp;gt;;
}

const Enhance = (WrappedComponent) =&amp;gt; class extends Component {
    constructor() {
        this.state = { data: null }; 
    }

    componentDidMount() {
        this.setState({ data: &quot;Hello&quot;});
    }

    render() {
        return &amp;lt;WrappedComponent {...this.props} data={this.state.data}/&amp;gt;
    }
}

export default Enhance(MyComponent);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上述代码所示，Enhance(MyComponent)就返回了一个HOC，这个返回的组件封装了MyComponent，因此，HOC可以完成以下一些常用的操作，比如: 操作props, 封装通用的样式等&lt;/p&gt;

&lt;h3&gt;操作props&lt;/h3&gt;

&lt;p&gt;例如如下代码: 判断登录用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const WithLoginUser = (WrappedComponent) =&amp;gt; (props) =&amp;gt; {
    const user = getCurrentLoginUser();
    return (
        &amp;lt;WrappedComponent {...props} user={user}/&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据props内容条件渲染&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const ConditionRender = (WrappedComponent) =&amp;gt; (props) =&amp;gt; {
    if (props.data !== null) {
        return null;
    } else {
        return &amp;lt;WrappedComponent {...props} /&amp;gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;封装通用的样式&lt;/h3&gt;

&lt;p&gt;可以做一些通用样式的处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const StyledComponent = (WrappedComponent) =&amp;gt; (props) =&amp;gt; {
    return (
        &amp;lt;div className=&quot;general-style&quot;&amp;gt;
            &amp;lt;WrappedComponent {...props} /&amp;gt;
        &amp;lt;/div&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考材料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@housecor/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc?swoff=true#.y0olcg5dt&quot;&gt;https://medium.com/@housecor/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc?swoff=true#.y0olcg5dt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://engineering.blogfoster.com/higher-order-components-theory-and-practice/&quot;&gt;http://engineering.blogfoster.com/higher-order-components-theory-and-practice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;https://facebook.github.io/react/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>TCP TIME_WAIT状态与tcp_tw_recycle</title>
   <link href="http://wangtaox.github.io/2016/09/02/tcp-time-wait.html"/>
   <updated>2016-09-02T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/09/02/tcp-time-wait</id>
   <content type="html">&lt;p&gt;最近遇到了一个与linux内核选项tcp_tw_recycle的坑, 在此记录一下相关知识点。&lt;/p&gt;

&lt;h3&gt;TIME_WAIT状态的作用&lt;/h3&gt;

&lt;p&gt;如图，TIME_WAIT状态主要用来处理数据的错误传输，比如一个连接，在断开后，又新建了相同的连接(IP和端口的四元组)，上一次断开的连接中某些数据可能由于网络拥塞而延迟到来，显然延迟的数据不是属于这一个新建的连接的，为了防止这种情况，TIME_WAIT状态会等待2&lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_segment_lifetime&quot;&gt;MSL&lt;/a&gt;，即两倍最大报文生存时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/files/2016/09/02/Time_wait.svg&quot; alt=&quot;time_wait&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图的黄色箭头所代表的即为不正确的数据。&lt;/p&gt;

&lt;h3&gt;tcp_tw_recycle&lt;/h3&gt;

&lt;p&gt;当在连接量较大的服务器上时，如果大量的TIME_WAIT状态会影响服务器的性能，因此，&lt;a href=&quot;https://tools.ietf.org/html/rfc6191#page-3&quot;&gt;RFC6191&lt;/a&gt;提出使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_timestamps&quot;&gt;TCP Timestamp&lt;/a&gt;来减少这样的TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;在内核中的代码实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;536 bool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst, bool paws_check)
537 {
538         struct tcp_metrics_block *tm;
539         bool ret;
540
541         if (!dst)
542                 return false;
543
544         rcu_read_lock();
545         tm = __tcp_get_metrics_req(req, dst);
546         if (paws_check) {
547                 if (tm &amp;amp;&amp;amp;
548                     (u32)get_seconds() - tm-&amp;gt;tcpm_ts_stamp &amp;lt; TCP_PAWS_MSL &amp;amp;&amp;amp;
549                     (s32)(tm-&amp;gt;tcpm_ts - req-&amp;gt;ts_recent) &amp;gt; TCP_PAWS_WINDOW)
550                         ret = false;
551                 else
552                         ret = true;
553         } else {
554                 if (tm &amp;amp;&amp;amp; tcp_metric_get(tm, TCP_METRIC_RTT) &amp;amp;&amp;amp; tm-&amp;gt;tcpm_ts_stamp)
555                         ret = true;
556                 else
557                         ret = false;
558         }
559         rcu_read_unlock();
560
561         return ret;
562 }
563 EXPORT_SYMBOL_GPL(tcp_peer_is_proven);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码中，547-552行主要确保在TCP_PAWS_MSL时间内请求的时间戳是递增的(TCP_PAWS_WINDOW为1)。&lt;/p&gt;

&lt;h3&gt;ipatbles NAT&lt;/h3&gt;

&lt;p&gt;所以当后端机器在NAT后面时，由于NAT并没有改时间戳，连接中的时间戳来自不同的机器，时间戳(机器启动时间)不一定是递增的，所以就会出现后端机器drop SYN包的情况.&lt;/p&gt;

&lt;p&gt;在NAT后的机器，关闭tcp_tw_recycle检查即可，一般该选项为disable的。&lt;/p&gt;

&lt;h3&gt;参考材料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://lxr.free-electrons.com/source/net/ipv4/tcp_metrics.c?v=3.10#L536&quot;&gt;http://lxr.free-electrons.com/source/net/ipv4/tcp_metrics.c?v=3.10#L536&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6191#page-3&quot;&gt;https://tools.ietf.org/html/rfc6191#page-3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/&quot;&gt;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#summary&quot;&gt;https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#summary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1323.txt&quot;&gt;https://www.ietf.org/rfc/rfc1323.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>flannel vxlan implementation</title>
   <link href="http://wangtaox.github.io/2016/07/29/flannel-vxlan.html"/>
   <updated>2016-07-29T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/07/29/flannel-vxlan</id>
   <content type="html">&lt;p&gt;flannel是&lt;a href=&quot;https://coreos.com/&quot;&gt;coreos&lt;/a&gt;为&lt;a href=&quot;http://kubernetes.io/&quot;&gt;kubernets&lt;/a&gt;提供的网络解决方案，主要为打通跨节点的容器通信，其中vxlan模式为flannel实现的一种后端模式，其他模式还包括&lt;strong&gt;udp&lt;/strong&gt;,
&lt;strong&gt;host-gw&lt;/strong&gt;等，可以通过&lt;a href=&quot;https://github.com/coreos/flannel&quot;&gt;flannel&lt;/a&gt;官网了解更多信息。&lt;/p&gt;

&lt;h3&gt;linux vxlan工作原理&lt;/h3&gt;

&lt;p&gt;flannel的vxlan模式使用的是原生的linux vxlan实现，因此了解linux vxlan工作原理对于理解flannel的代码实现很有帮助。&lt;/p&gt;

&lt;p&gt;在linux vxlan中，主要术语:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L3 Miss: 目标IP在邻居表中未找到 (IP Miss，所以才叫L3 Miss吗？)&lt;/li&gt;
&lt;li&gt;L2 Miss: 目标MAC在vxlan FDB中未找到对应项 (2层的Miss)&lt;/li&gt;
&lt;li&gt;NOLEARNING: 禁止洪泛数据包 (在FDB中未找到相应表项)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;vxlan fdb&lt;/strong&gt; 主要映射目标MAC到vtep IP。&lt;/p&gt;

&lt;p&gt;如图 &lt;img src=&quot;/media/files/2016/08/01/linux_vxlan.svg&quot; alt=&quot;flannel-ovs&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;创建vxlan device
$ip link add vxlan0 type vxlan id 42 group 239.1.1.1 dev eth0
$ip link set vxlan0 address 54:8:20:0:0:A
$ip address add 10.10.10.1 dev vxlan0
$ip link set up vxlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;host－A 10.10.10.1 ping host-B 10.10.11.1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;Host-A $ping 10.10.11.1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;host-A vxlan0接口生成arp请求10.10.11.1的mac地址&lt;/li&gt;
&lt;li&gt;vxlan 驱动封装添加VNI header，没有已知的目的mac，使用多播地址&lt;/li&gt;
&lt;li&gt;eth0 发出数据包&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在host－B上，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;host－B收到数据包然后转发给相应的udp端口(vxlan)&lt;/li&gt;
&lt;li&gt;vxlan驱动解封装，vxlan0接收到arp request包，并生成相应的arp reply包，添加相应的vxlan header，目的mac为56:bb:01:0f:cb:A&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这样在host-B的fdb中，会学到56:bb:01:0f:cb:A到转发规则，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;Host-B $bridge fdb show dev vxlan0
56:bb:01:0f:cb:A dev vxlan0 dst 192.168.1.10 self
0:0:0:0:0:0 dev vxlan0 dst 239.1.1.1 via eth0 self permanent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二条规则就是在目的mac为止时使用多播地址的相应规则。&lt;/p&gt;

&lt;h3&gt;flannel实现方式&lt;/h3&gt;

&lt;p&gt;因为flannel是为k8s提供的网络解决方案，而在k8s中，每一台host会分配一个网段，该网段所有启动的容器均在这台机器上，所以，对于flnanel来说，很多信息都是已知的，可以简化flannel的vxlan fdb(不需要处理未知的MAC地址情况)以及相应的代码实现。&lt;/p&gt;

&lt;p&gt;在flannel中，flannel会在每一台启动了flannel agentd的机器上创建一个vxlan device(上述的vxlan0)，名称是flannel.1(1为vni号)，flannel agent会根据分配的网段信息和vxlan device信息(vxlan device的mac地址)，动态的修改host上的邻居表，并结合vxlan device的fdb实现跨主机的docker容器的通信。&lt;/p&gt;

&lt;h4&gt;一个例子&lt;/h4&gt;

&lt;p&gt;flannel的网段分配信息是通过etcd 记录的，在etcd中设置相应信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;etcd $etcdctl get /flannel/network/config
{ &quot;Network&quot;: &quot;10.10.0.0/16&quot;, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot;, &quot;VNI&quot;: 1 } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在host-A上运行flannel agent，agent在etcd中分配网段10.10.10.0/24，agent创建flannel.1设备接口，配置IP 10.10.10.0 MAC 56:bb:01:0f:cb:A，配置路由，整个大段通过flannel.1, 这样overlay网络流量通过flannel.1转发处理，然后启动docker0，通过指定bip 10.10.10.1/24启动，这样在host-A上的容器使用网段10.10.10.1/24。&lt;/p&gt;

&lt;p&gt;同理在host-B上运行flannel agent，agent进行的相应配置过程类似。&lt;/p&gt;

&lt;p&gt;整个例子如图&lt;img src=&quot;/media/files/2016/08/01/flannel-vxlan.svg&quot; alt=&quot;flannel-vxlan&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;flannel vxlan相应工作流程&lt;/h4&gt;

&lt;p&gt;由于flannel agentd知道所有的网段分配信息以及每台host上的flannel.1设备的IP，MAC，因此每一个网段在进行vxlan fdb转发时，可以使用host上flannel.1的MAC地址。&lt;/p&gt;

&lt;p&gt;在host-A上，运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host-A# bridge fdb show dev flannel.1
56:bb:01:0f:cb:B dst 192.168.1.11 self permanent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在host－B上，运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host-B# bridge fdb show dev flannel.1
56:bb:01:0f:cb:A dst 192.168.1.10 self permanent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如图c1 ping c2时，如果容器c1 IP(10.10.10.2), 容器c2 IP(10.10.11.2),
因为host－A 的邻居表里没有c2 IP到MAC表项，flannel agent会收到相应的l3 miss(netlink)消息，然后flannel agent会反应式的设置c2 的IP到MAC表项为10.10.11.2-56:bb:01:0f:cb:B，这样在fdb中MAC 56:bb:01:0f:cb:B就对应到host-B的flannel.1。&lt;/p&gt;

&lt;p&gt;因为flannel知道必要的网络信息，所以flannel直接按段处理了L3 miss的消息，L2的fdb直接在启动时根据etcd信息静态配置好，这样整个网络就连通了。&lt;/p&gt;

&lt;h4&gt;L3 miss代码&lt;/h4&gt;

&lt;p&gt;如代码，在L3 miss代码中，通过miss的IP在所有段里匹配然后设置对应的vtepMac，即:
上述的c2 IP是对应到网段10.10.11.0/24的，然后相应的vtepMAC就对应到host-B的flannel.1的MAC，代码中是通过路由信息记录的，也保存了设备的MAC。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;golang&quot;&gt;func (n *network) handleL3Miss(miss *netlink.Neigh) {
    log.Infof(&quot;L3 miss: %v&quot;, miss.IP)

    rt := n.rts.findByNetwork(ip.FromIP(miss.IP))
    if rt == nil {
        log.Infof(&quot;Route for %v not found&quot;, miss.IP)
        return
    }

    if err := n.dev.AddL3(neigh{IP: ip.FromIP(miss.IP), MAC: rt.vtepMAC}); err != nil {
        log.Errorf(&quot;AddL3 failed: %v&quot;, err)
    } else {
        log.Info(&quot;AddL3 succeeded&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L2的代码也可以在该函数&lt;a href=&quot;https://github.com/coreos/flannel/blob/master/backend/vxlan/network.go&quot;&gt;所在文件&lt;/a&gt;中找到。&lt;/p&gt;

&lt;h4&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://events.linuxfoundation.org/sites/events/files/slides/2013-linuxcon.pdf&quot;&gt;http://events.linuxfoundation.org/sites/events/files/slides/2013-linuxcon.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lartc.org/howto/lartc.kernel.obscure.html&quot;&gt;http://lartc.org/howto/lartc.kernel.obscure.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hustcat.github.io/vxlan-l3miss-problem/&quot;&gt;http://hustcat.github.io/vxlan-l3miss-problem/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>max-width和width</title>
   <link href="http://wangtaox.github.io/2016/07/08/max-width-and-width.html"/>
   <updated>2016-07-08T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/07/08/max-width-and-width</id>
   <content type="html">&lt;p&gt;以下max-width及width使用方式区别:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.modal-one {
    ...
    width: 800px;
    max-width: 100%;
}

or

.modal-two {
    ...
    width: 100%;
    max-width: 800px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Scenario 1: parent is wider than 800px&lt;/h4&gt;

&lt;p&gt;parent is 1000px wide&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.modal-one&lt;/code&gt; 显示width为800px, max-width为1000px, width未超过max-width, 则width最终为800px&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.modal-two&lt;/code&gt; 显示width为1000px, max-width为800px, width超过了max-width, 则width最终为800px&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;Scenario 2: parent is smaller than 800px&lt;/h4&gt;

&lt;p&gt;parent is 460px wide&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.modal-one&lt;/code&gt; 显示width为800px, max-width为460px, width超过max-width, 则width最终为460px&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.modal-two&lt;/code&gt; 显示width为460px, max-width为800px, width未超过max-width, 则width最终为460px&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;因此, 一个元素如果width大于max-width, max-width是高于width的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>&quot;CSS secrets&quot; Reading Notes</title>
   <link href="http://wangtaox.github.io/2016/05/14/css-secret-reading-notes.html"/>
   <updated>2016-05-14T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/05/14/css-secret-reading-notes</id>
   <content type="html">&lt;h3&gt;currentColor&lt;/h3&gt;

&lt;p&gt;In css3, we got a special new color keyword &lt;strong&gt;currentColor&lt;/strong&gt;, which always resolves to the value of the &lt;strong&gt;color&lt;/strong&gt; property, make it &lt;strong&gt;the first ever variable&lt;/strong&gt; in css.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.dont-do-this {
  height: 2em;
  width: 1em;
  background: currentColor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will become even more useful when we get functions to manipulate colors in native css.&lt;/p&gt;

&lt;h3&gt;Use shorthands wisely&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.positive-bg {
  background: blue;
  /*background-color: blue;*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is good defensive coding and future-proofing to use them, unless we intentionally want to use cascaded properties.&lt;/p&gt;

&lt;h3&gt;background-clip&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.photo-box {
  border: .4em solid rgba(255, 255, 255, .5);
  border-radius: .4em;
  font-size: 120%;
  line-height: 1.5;
  width: 720px;
  background: rgba(255, 255, 255);
  background-clip: padding-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;outline&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;outline&lt;/strong&gt; do not fellow the elements’s rounding but &lt;strong&gt;box-shadow&lt;/strong&gt; do&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.box {
  background: blue;
  border-radius: .8em;
  padding: 1em;
  box-shadow: 0 0 0 .8em red;
  outline: .8em solid red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;linear-gradient&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.bg {
  background: linear-gradient(red 20%, blue 80%);
  ....
  /* 80% － 20% is the length of gradient area */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we set the color position at 0, it means its position is set to where the previous one stop.&lt;/p&gt;

&lt;h3&gt;box-shadow&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.box {
  box-shadow: 0 0 10px blue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;z-index&lt;/h3&gt;

&lt;p&gt;First of all, z-index only works on positioned elements. If you try to set a z-index on an element with no position specified, it will do nothing. Secondly, z-index values can create stacking contexts.&lt;/p&gt;

&lt;p&gt;Every stacking context has a single HTML element as its root element. When a new stacking context is formed on an element, that stacking context confines all of its child elements to a particular place in the stacking order, That means that if an element is contained in a stacking context at the bottom of the stacking order, there is no way to get it to appear in front of another element in a different stacking context that is higher in the stacking order, even with a z-index of a billion!&lt;/p&gt;

&lt;p&gt;New stacking contexts can be formed on an element in one of three ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When an element is the root element of a document (the &lt;strong&gt;html&lt;/strong&gt; element)&lt;/li&gt;
&lt;li&gt;When an element has a position value other than static and a z-index value other than auto&lt;/li&gt;
&lt;li&gt;When an element has an opacity value less than 1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In addition to opacity, several newer CSS properties also create stacking contexts. These include: transforms, filters, css-regions, paged media, and possibly others. As a general rule, it seems that if a CSS property requires rendering in an offscreen context, it must create a new stacking context.&lt;/p&gt;

&lt;p&gt;Here are the basic rules to determine stacking order within a single stacking context (from back to front):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The stacking context’s root element&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with negative z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Non-positioned elements (ordered by appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with a z-index value of auto (ordered by appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with positive z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Note: positioned elements with negative z-indexes are ordered first within a stacking context, which means they appear behind all other elements. Because of this, it becomes possible for an element to appear behind its own parent, which is normally not possible. This will only work if the element’s parent is in the same stacking context and is not the root element of that stacking context.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>&quot;flip&quot;动画</title>
   <link href="http://wangtaox.github.io/2016/03/28/flip.html"/>
   <updated>2016-03-28T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/03/28/flip</id>
   <content type="html">&lt;h3&gt;flip动画&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;first: 元素在动画中的初始状态&lt;/li&gt;
&lt;li&gt;last: 元素的动画的结束状态&lt;/li&gt;
&lt;li&gt;invert: 计算first和last状态的差值，然后设置相应的属性(transform, opacity等)，使元素在初始状态。&lt;/li&gt;
&lt;li&gt;play: 触发整个动画&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;一个例子🌰&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;head&amp;gt;
  &amp;lt;style media=&quot;screen&quot;&amp;gt;
    body {
    }

    .container {
      width: 100%;
      height: 100%;
      margin: 0 auto;
      background: #BBDEFB;
      position: relative;
    }

    .circle {
      width: 100px;
      height: 100px;
      border-radius: 100%;
      background-color: #E1BEE7;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    .circle-end {
      top: auto;
      left: auto;
      bottom: 10px;
      right: 10px;
    }

  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;button type=&quot;button&quot; name=&quot;button&quot; onclick=&quot;doAnimate()&quot;&amp;gt;Animate&amp;lt;/button&amp;gt;
  &amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;circle&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  function doAnimate() {
    var node = document.getElementsByClassName(&#39;circle&#39;)[0]

    //计算初始属性
    var first = node.getBoundingClientRect()
    node.classList.add(&#39;circle-end&#39;)
    //计算结束属性
    var last = node.getBoundingClientRect()

    //invert
    var invertX = first.left - last.left
    var invertY = first.top - last.top

    node.style.transform = &#39;translate(&#39; + invertX + &#39;px,&#39; + invertY + &#39;px)&#39;
    node.style.transition = &#39;transform 0s&#39;

    requestAnimationFrame(function(node) {
      return function() {

        //触发动画
        node.style.transition = &#39;all 1s&#39;;
        node.style.transform  = &#39;&#39;;
        console.log(node)
      }
    }(node))
  }

  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;requestAnimationFrame函数&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;requestAnimationFrame&lt;/a&gt;函数主要告诉浏览器在重绘每一帧动画时，可以运行用户定义的代码，可以进行相应的计算等等。&lt;/p&gt;

&lt;h4&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/developers-writing/animating-the-unanimatable-1346a5aab3cd#.86itpf3ga&quot;&gt;Animating the Unanimatable.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP Your Animations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>理解javascript promise</title>
   <link href="http://wangtaox.github.io/2016/03/04/promise.html"/>
   <updated>2016-03-04T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/03/04/promise</id>
   <content type="html">&lt;h3&gt;so promise ？&lt;/h3&gt;

&lt;p&gt;promise，翻译过来就是承诺的意思，在javascript中，promise是一个关于异步操作的结果的“承诺”,
可以在&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;promise A+ spec&lt;/a&gt;中了解更多关于promise的信息。&lt;/p&gt;

&lt;p&gt;在此翻译了pouchdb中关于promise的博客，以加深对promise的理解。&lt;a href=&quot;https://twitter.com/nolanlawson&quot;&gt;作者&lt;/a&gt;在推上发了一段关于promise的代码，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//case 1
doSomething().then(function() {
    return doSomethingElse()
})
//case 2
doSomething().then(function() {
    doSomethingElse()
})
//case 3
doSomething().then(doSomethingElse())
//case 4
doSomething().then(doSomethingElse)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: &lt;code&gt;doSomething&lt;/code&gt;及&lt;code&gt;doSomethingElse&lt;/code&gt;都是一个函数并返回新的promise.&lt;/p&gt;

&lt;p&gt;知道几个case的区别么? #@!...以下代码可能会使用一些ES6语法。&lt;/p&gt;

&lt;h3&gt;坑1: 回调金字塔&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then((resultOfUsers) =&amp;gt; {
    resultOfUsers.forEach((user) =&amp;gt; {
        localStorageWithPromise.put(user).then(() =&amp;gt; {
            console.log(`put user ${user.name} to localStorage success!`)
        }).catch((err) =&amp;gt; {
            console.log(`put user ${user.name} to localStorage failed!`)
            localStorageWithPromise.remove(user.id).then(() =&amp;gt; {
                console.log(`remove possible user info with user id : ${user.id}`)
            })
            ...
        })
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当我们需要完成更复杂的一些回调操作时，可能代码比这还嵌套得深，这样代码的可读性以及可维护性就会很糟糕，而更好的书写
方式应该这样，称为&lt;code&gt;组合promise&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    return Promise.all(resultOfUsers.forEach((user) =&amp;gt; {
        return localStorageWithPromise.put(user)
    }))
}).then((resultInfo) =&amp;gt; {
    console.log(`put result ${resultInfo}`)
}).catch((err) =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更直观一点，或许我们应该组织我们的promise调用链如下面这样的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;operationA().then((resultOfA) =&amp;gt; {
    return doWithResultA(resultOfA)
}).then((resultFromA) =&amp;gt; {
    return operationB(resultFromA)
}).then((resultFromB) =&amp;gt; {
    return operationC(resultFromB)
}).catch(err =&amp;gt; {
    console.log(`any errors &quot;${err}&quot; happened in promise chain`)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样整个调用链会比较清晰，且可以统一的&lt;code&gt;catch&lt;/code&gt;错误并处理。&lt;/p&gt;

&lt;h3&gt;坑2: forEach与promise&lt;/h3&gt;

&lt;p&gt;比如如下的操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    resultOfUsers.forEach(user =&amp;gt; {
        user.remove()
    })
}).then(() =&amp;gt; {
    //以为已经删除了所有用户
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多时候我们以为这样写就可以了，其实是错误的，第二个then回调并不会等待所有user被删除才执行，因为在第一个then回调中，函数返回
的是&lt;code&gt;undefined&lt;/code&gt;, 所以这样的写法就会存在bug, 正确的写法应该如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    return Promise.all(resultOfUsers.forEach(user =&amp;gt; {
        return user.remove()
    }))
}).then(() =&amp;gt; {
    console.log(&quot;all users has been deleted.&quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第一个then回调中返回了promise，并使用了&lt;code&gt;promise.all&lt;/code&gt;, 注意&lt;code&gt;user.remove&lt;/code&gt;也是返回promise的。&lt;/p&gt;

&lt;h3&gt;坑3: 忘记catch错误&lt;/h3&gt;

&lt;p&gt;我们不应该去假设我们的promise不返回任何错误，应该在promise调用中都进行正确的错误处理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return opReturnPromise2()
}).then(() =&amp;gt; {
    return opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;promise中的返回值&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    opReturnPromise2()
}).then(() =&amp;gt; {
    opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有什么问题么？这儿在promise的回调中&lt;code&gt;返回值存在问题&lt;/code&gt;, 在promise中，then()回调可以返回:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;返回另一个promise.&lt;/li&gt;
&lt;li&gt;返回一个值(或者undefined).&lt;/li&gt;
&lt;li&gt;返回一个错误.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;返回另一个promise&lt;/h4&gt;

&lt;p&gt;这就是上面提到的&lt;code&gt;组合promise&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return opReturnPromise2()
}).then(() =&amp;gt; {
    return opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;返回一个值(或者undefined)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUserFromRESTAPI(userName).then((userInfo) =&amp;gt; {
    if (FriendsCache[userInfo.id]) {
        return FriendsCache[userInfo.id]
    }
    return getUserFriends(userInfo.id)
}).then((friends) =&amp;gt; {
    console.log(friends)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写是不是很清晰，在第二个处理friends的then回调中，我不需要关心friends是在cache中还是从API中获取的，处理得到的好友列表即可。
由于在javascript中，函数不显视的返回任何值，则返回undefined，所有在promise的then回调中，建议总是返回一个值或者抛出错误。&lt;/p&gt;

&lt;h4&gt;返回一个错误&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUserFromRESTAPI(userName).then((userInfo) =&amp;gt; {
    if (isLoggedout(userInfo.id)) {
        throw new Error(&quot;logged out!&quot;)
    }
    if (FriendsCache[userInfo.id]) {
        return FriendsCache[userInfo.id]
    }
    return getUserFriends(userInfo.id)
}).then((friends) =&amp;gt; {
    console.log(friends)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;巧用Promose.resolve&lt;/h3&gt;

&lt;p&gt;使用promise包装同步的代码使其异步化，并进行错误处理。对于同步的操作，promise也可以提供很多帮助，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let caculateSomethingAndMayThrowError  = (x, y) =&amp;gt; {
    if (x &amp;lt; y) {
        throw new Error(&quot;x &amp;lt; y&quot;)
    }
    return x - y
}

let wrapAPI2Promise = () =&amp;gt; {
    return Promise.resolve().then(() =&amp;gt; {
        let value = caculateSomethingAndMayThrowError()
        return value
    }).then((value) =&amp;gt; {
        console.log(value)
    }).catch((err) =&amp;gt; {
        console.log(err)
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在catch中我们可以处理同步函数抛出的异常.&lt;/p&gt;

&lt;h3&gt;避免reject函数，使用catch&lt;/h3&gt;

&lt;p&gt;catch函数其实是一个语法糖, 如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().catch((err) =&amp;gt; {})
//equal to
promise1().then(null, (err) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如下的代码却并不一样，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return promise2()
}).catch((err) =&amp;gt; {
    console.log(err)
})

promise1().then(() =&amp;gt; {
    return promise2()
}, (err) =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个catch会处理整个promise链中的异常错误，但是第二个却是处理promise1的异常错误，因为它相当于promise1的reject函数。
所以一般情况下建议只用catch函数，避免给then传递第二个参数导致理解错误，出现bug。&lt;/p&gt;

&lt;h3&gt;promise工厂函数&lt;/h3&gt;

&lt;p&gt;有时可以通过工厂函数，组合我们的promise链，但是一定要注意返回值, 例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//依次sleep 1s

let suspendOneSecondFactory = () =&amp;gt; {
    return () =&amp;gt; {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(() =&amp;gt; {
                console.log(&#39;sleep 1s&#39;)
                resolve()
            }, 1000)
        })
    }
}

let result = Promise.resolve()
[1, 2, 3].forEach(() =&amp;gt; {
    result = result.then(suspendOneSecondFactory())
})
result.then(() =&amp;gt; {
    console.log(&quot;the end&quot;)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;promise在使用时一定要注意then回调的返回值，以及组合使用promise，并将操作尽量步骤化，那样可以使用proise链组合出各种需要的
依赖链并进行调用, 如果给then调用传递非函数值，在then调用中传递的非函数值会被解析为null。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>React lifecycle hooks notes</title>
   <link href="http://wangtaox.github.io/2016/02/25/react-lifecycle.html"/>
   <updated>2016-02-25T14:42:35+08:00</updated>
   <id>http://wangtaox.github.io/2016/02/25/react-lifecycle</id>
   <content type="html">&lt;h3&gt;Component Life Cycle Hooks&lt;/h3&gt;

&lt;p&gt;React provides a series of life cycle hooks we can tap into each phase of the life cycle, each of the life cycle hooks are called in specific order and at a specific time.&lt;/p&gt;

&lt;h4&gt;component创建&lt;/h4&gt;

&lt;p&gt;组件的创建主要步骤包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;component初始化&lt;/li&gt;
&lt;li&gt;component.defaultProps获取component的props&lt;/li&gt;
&lt;li&gt;this.state = ...(ES6的class constructor函数)&lt;/li&gt;
&lt;li&gt;componentWillMount()函数&lt;/li&gt;
&lt;li&gt;render()函数&lt;/li&gt;
&lt;li&gt;子组件的初始化以及生命周期函数&lt;/li&gt;
&lt;li&gt;componentDidMount()函数&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;注意传递props时的null值，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//right
&amp;lt;Box name={null}&amp;gt; //pass null to props is tricky

//wrong
&amp;lt;Box name={undefined}&amp;gt;

class Box extends React.Componets {
  constructor(props) {
    super(props);
    this.state = { open: false };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在constructor函数中需要给state赋值，不然this.state就是undefined了.&lt;/p&gt;

&lt;p&gt;当props和state都设置好后，就会进入第一个生命周期函数componentWillMount，记住在该函数中Dom还未mount，因此访问
this.refs是不允许的，在该函数中我们可以为调整state或者为第一次render做一些前期工作，比如注册一些全局的事件(window.resize)。&lt;/p&gt;

&lt;p&gt;It&#39;s important to remember that many Native UI elements do not exist at this point in the life cycle. That means we need to stick to very high-level/global events such as window or document.&lt;/p&gt;

&lt;p&gt;在render函数中，我们根据props和state对组件进行渲染，因此，render应该是一个pure function，componentUI = render(props, state)，在render就不应该调用setState函数了，同时也不应该在render中操作DOM.&lt;/p&gt;

&lt;p&gt;有子组件存在时，渲染子组件，类似DFS？&lt;/p&gt;

&lt;p&gt;在componentDidMount函数中，我们可以访问Native UI了，所以在该函数中根据UI进行一些操作时可以的，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;componentDidMount() {
  this.chart = highcharts.Highcharts({
    elem: this.refs.chart,
    ...
  });

  this.table = DataTable.Table({
    ...
  });

  $(.css_class).xxx();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;component更新&lt;/h4&gt;

&lt;p&gt;组件的更新主要步骤包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;componentWillReceiveProps()函数&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate()函数&lt;/li&gt;
&lt;li&gt;render()函数&lt;/li&gt;
&lt;li&gt;子组件的生命周期函数&lt;/li&gt;
&lt;li&gt;componentWillUpdate()函数&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;componentWillReceiveProps(nextProps)函数会在props传递给component时调用，可以对比props。&lt;/p&gt;

&lt;p&gt;The core issue with props and componentWillReceiveProps() is how JavaScript provides mutable data structures. Let&#39;s say we have a prop called data and data is an Array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// psuedo code
this.setState({ data: [1, 2, 3] });

&amp;lt;MyComponent data={ this.state.data } /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js中Object时引用的，因此在React中要格外注意。&lt;/p&gt;

&lt;p&gt;The next method in the Update life cycle, is shouldComponentUpdate(). This method allows your Component to exit the Update life cycle if there is no reason to apply a new render. Out of box, the shouldComponentUpdate() is a no-op that returns true. This means every time we start an Update in a Component, we will re-render.
If you recall, React does not deeply compare props by default. When props or state is updated React assumes we need to re-render the content. But, if the props or state have not changed, should we really be re-rendering?&lt;/p&gt;

&lt;p&gt;Once we have determined that we do need to re-render in our Update phase, the componentWillUpdate() will be called. The method is passed in two arguments: nextProps and nextState. The method componentWillUpdate() is similar to componentWillMount(), and many of the same considerations and tasks are the same. The difference being that componentWillUpdate() is called every time a re-render is required and we get access to the next props and state.&lt;/p&gt;

&lt;p&gt;Just like componentWillMount(), this method is called before render(). Because we have not rendered yet, our Component&#39;s access to the Native UI (DOM, etc.) will reflect the old rendered UI. Unlike, componentWillMount() we can technically access refs but it is not recommended because the refs will also be out of date.+&lt;/p&gt;

&lt;p&gt;The componentWillUpdate() is a chance for us to handle configuration changes, update our state and in general prepare for the next render. If we want to access the old props or state, we can call this.props or this.state. We can then compare them to the new values and make changes/calculations as required.&lt;/p&gt;

&lt;p&gt;Continuing the trend of corresponding methods, the componentDidUpdate() is the Update version of componentDidMount(). Once again, we can access the Native UI stack, interact with our refs and if required start another re-render/update.&lt;/p&gt;

&lt;p&gt;When componentDidUpdate() is called, two arguments are passed: prevProps and prevState. This is the inverse of componentWillUpdate(). The passed values are what the values were and accessing this.props and this.state are the current values&lt;/p&gt;

&lt;p&gt;The most common uses of componentDidUpdate() is managing 3rd party UI elements and interacting with the Native UI. When using 3rd Party libraries, like our Chart example, we need to update the UI library with new data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;componentDidUpdate(prevProps, prevState) {
  // only update chart of the data has changed
  if (prevProps.data !== this.props.data) {
    this.chart = c3.load({
      data: this.props.data
    });
  }
}

//Another render pass?
componentDidUpdate(prevProps, prevState) {
  // One possible fix...
  let height = ReactDOM.findDOMNode(this).offsetHeight;
  if (this.state.height !== height ) {
    this.setState({ internalHeight: height });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;component挂载&lt;/h4&gt;

&lt;p&gt;组件的卸载和清楚步骤包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;componentWillUnmount()&lt;/li&gt;
&lt;li&gt;子组件生命周期函数&lt;/li&gt;
&lt;li&gt;component GC&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Just like the rest of our life cycle phases, the Death/Unmount phase has a method hook for us. This method allows us to do some cleanup before we are removed from the UI stack. Typically we want to reverse any setup we did in either componentWillMount() or componentDidMount().&lt;/p&gt;

&lt;p&gt;For example, we would want to unregister any global/system/library events, destroy 3rd party UI library elements, etc. If we don&#39;t take the time to remove events we can create memory leaks in our system or leave bad references laying around.&lt;/p&gt;

&lt;h4&gt;redux&lt;/h4&gt;

&lt;p&gt;redux reducer, 根据action和state得出新的state， (prevState, action) =&gt; newState, 和我们熟悉的Array.prototype.reduce(reducer, prevValue)类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let initiaState = { count: 0 }

//counter example
let actions = [
    {type: &#39;INC&#39;},
    {type: &#39;DEC&#39;},
]

//take actions and state as paramaters, output new state.
function counterReducer(state = initiaState, action) {
    switch(action.type) {
        case &#39;INC&#39;:
            return Object.assign({}, state, {
                count: state.count++
            })
        case &#39;DEC&#39;:
            return Object.assign({}, state, {
                count: state.count--
            })
        default:
            return initiaState
    }
}
console.log(actions.reduce(counterReducer, initiaState))
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>golang grpc学习</title>
   <link href="http://wangtaox.github.io/2016/02/01/grpc.html"/>
   <updated>2016-02-01T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/02/01/grpc</id>
   <content type="html">&lt;h3&gt;grpc简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.grpc.io/&quot;&gt;grpc&lt;/a&gt;是Google开源的rpc框架，使用&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;protobuf&lt;/a&gt;进行数据编码，，基于Http2协议，提供了很多优势，比如:双向的数据流，流控制，包头压缩，多路复用等，详细信息可以参考grpc官网。&lt;/p&gt;

&lt;h3&gt;protobuf3&lt;/h3&gt;

&lt;p&gt;protobuf是Google提供的一个跨语言的数据编码机制，支持多种语言，在结合RPC使用时，可以节省带宽，提高传输效率，grpc提供了protobuf的相应工具，这样就可以使用proto文件定义RPC接口，约定传输数据格式，通过生成工具生成相应语言的源文件。&lt;/p&gt;

&lt;h3&gt;定义一个文件传输服务&lt;/h3&gt;

&lt;p&gt;以下为一个文件服务的proto文件定义, file.proto :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;protocol&quot;&gt;syntax ＝ &quot;proto3&quot;;

package filetransfer;

//rpc调用定义
service FileServer {
  rpc GetFile(FileDescriptor) returns (stream FileContent) {}
}

message FileDescriptor {
  string filename = 1;
}

message FileContent {
  bytes content = 1;
  string md5sum = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过工具生成相应语言源代码，以&lt;a href=&quot;http://golang.org&quot;&gt;golang&lt;/a&gt;为例，使用如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;protoc --go_out=plugins=grpc:. file.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是服务端的代码实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;const (
  BUFSIZE = 1024
)

func (am *AgentManager) GetFile(fd *pb.FileDescriptor, stream pb.FileServer_GetFileServer) error {
  filename := fd.Filename

  //make sure file existed.
  fo, err := os.Open(filename)
  if err != nil {
    return ErrNoSuchFile
  }
  defer func() {
      if err := fo.Close(); err != nil {
        panic(err)
      }
  }()

  content := &amp;amp;pb.FileContent {
    Content: make([]byte, BUFSIZE),
    Md5Sum: caculateMd5(filename),
  }
  for {
    n, err := fo.Read(content.Content)
    if err != nil &amp;amp;&amp;amp; err != io.EOF {
      return ErrReadFile
    }
    if n == 0 {
      break
    }

    if err := stream.Send(content); err != nil {
      return err
    }
  }

  //indicate the end of stream.
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是Client端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;
func ReadFile(filename string, conn pb.FileServerClient) error {
  stream, err := conn.GetFile(filename)
  if err != nil {
    panic(err)
  }

  outFd, err := os.Create(filename)
  if err != nil {
    panic(err)
  }
  defer func() {
      if err := outFd.Close(); err != nil {
        panic(err)
      }
  }()

  for {
    content, err := stream.Recv()
    if err == io.EOF {
      break
    }
    if err != nil {
      panic(err)
    }

    if err := outFd.Write(content.Content); err != nil {
      panic(err)
    }
  }

  return nil
}


func checkMd5(filename string, md5 string) bool {
  return caculateMd5(filename) == md5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码有部分省略.&lt;/p&gt;

&lt;h3&gt;grpc stream&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;protobuf&quot;&gt;syntax = &quot;proto3&quot;;

package chatservice;

service chatservice {
  //双向的stream
  rpc chat(stream ChatMessage) returns (ChatMessage) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grpc的stream可以是双向的也可以是单向的，在通过proto文件定义时指定，比如: 也可以实现如Chat这样的接口。&lt;/p&gt;

&lt;h3&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://talks.golang.org/2015/gotham-grpc.slide#1&quot;&gt;http://talks.golang.org/2015/gotham-grpc.slide#1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coreos.com/blog/gRPC-protobufs-swagger.html&quot;&gt;https://coreos.com/blog/gRPC-protobufs-swagger.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coreos/etcd/blob/master/etcdserver/etcdserverpb/rpc.proto&quot;&gt;https://github.com/coreos/etcd/blob/master/etcdserver/etcdserverpb/rpc.proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gengo/grpc-gateway&quot;&gt;https://github.com/gengo/grpc-gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 
</feed>
