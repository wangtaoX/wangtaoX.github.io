<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>奔跑的蚂蚁</title>
 <link href="http://wangtaox.github.io/atom.xml" rel="self"/>
 <link href="http://wangtaox.github.io"/>
 <updated>2016-09-27T21:04:07+08:00</updated>
 <id>http://wangtaox.github.io/</id>
 <author>
   <name>TaoWang</name>
 </author>

 
 <entry>
   <title>React higher order component</title>
   <link href="http://wangtaox.github.io/2016/09/26/react-hoc.html"/>
   <updated>2016-09-26T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/09/26/react-hoc</id>
   <content type="html">&lt;h3&gt;什么是Higher Order Component ?&lt;/h3&gt;

&lt;p&gt;HOC(Higher Order Component)主要用来封装(增强)其它组件，即一个组件封装了另外一个组件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const MyComponent = (props) =&amp;gt; {}
   if (props.data) {
       return (
            &amp;lt;h1&amp;gt;Waiting&amp;lt;/h1&amp;gt;
       );
   }

   return &amp;lt;div&amp;gt;{props.data}&amp;lt;/div&amp;gt;;
}

const Enhance = (WrappedComponent) =&amp;gt; class extends Component {
    constructor() {
        this.state = { data: null }; 
    }

    componentDidMount() {
        this.setState({ data: &quot;Hello&quot;});
    }

    render() {
        return &amp;lt;WrappedComponent {...this.props} data={this.state.data}/&amp;gt;
    }
}

export default Enhance(MyComponent);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上述代码所示，Enhance(MyComponent)就返回了一个HOC，这个返回的组件封装了MyComponent，因此，HOC可以完成以下一些常用的操作，比如:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;操作props&lt;/li&gt;
&lt;li&gt;封装通用的样式&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;操作props&lt;/h3&gt;

&lt;p&gt;例如如下代码: 判断登录用户&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const WithLoginUser = (WrappedComponent) =&amp;gt; (props) =&amp;gt; {
    const user = getCurrentLoginUser();
    return (
        &amp;lt;WrappedComponent {...props} user={user}/&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据props内容条件渲染&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const ConditionRender = (WrappedComponent) =&amp;gt; (props) =&amp;gt; {
    if (props.data !== null) {
        return null;
    } else {
        return &amp;lt;WrappedComponent {...props} /&amp;gt;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;封装通用的样式&lt;/h3&gt;

&lt;p&gt;可以做一些通用样式的处理&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const StyledComponent = (WrappedComponent) =&amp;gt; (props) =&amp;gt; {
    return (
        &amp;lt;div className=&quot;general-style&quot;&amp;gt;
            &amp;lt;WrappedComponent {...props} /&amp;gt;
        &amp;lt;/div&amp;gt;
    )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;参考材料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@housecor/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc?swoff=true#.y0olcg5dt&quot;&gt;https://medium.com/@housecor/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc?swoff=true#.y0olcg5dt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://engineering.blogfoster.com/higher-order-components-theory-and-practice/&quot;&gt;http://engineering.blogfoster.com/higher-order-components-theory-and-practice/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;https://facebook.github.io/react/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>TCP TIME_WAIT状态与tcp_tw_recycle</title>
   <link href="http://wangtaox.github.io/2016/09/02/tcp-time-wait.html"/>
   <updated>2016-09-02T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/09/02/tcp-time-wait</id>
   <content type="html">&lt;p&gt;最近遇到了一个与linux内核选项tcp_tw_recycle的坑, 在此记录一下相关知识点。&lt;/p&gt;

&lt;h3&gt;TIME_WAIT状态的作用&lt;/h3&gt;

&lt;p&gt;如图，TIME_WAIT状态主要用来处理数据的错误传输，比如一个连接，在断开后，又新建了相同的连接(IP和端口的四元组)，上一次断开的连接中某些数据可能由于网络拥塞而延迟到来，显然延迟的数据不是属于这一个新建的连接的，为了防止这种情况，TIME_WAIT状态会等待2&lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_segment_lifetime&quot;&gt;MSL&lt;/a&gt;，即两倍最大报文生存时间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/media/files/2016/09/02/Time_wait.svg&quot; alt=&quot;time_wait&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图的黄色箭头所代表的即为不正确的数据。&lt;/p&gt;

&lt;h3&gt;tcp_tw_recycle&lt;/h3&gt;

&lt;p&gt;当在连接量较大的服务器上时，如果大量的TIME_WAIT状态会影响服务器的性能，因此，&lt;a href=&quot;https://tools.ietf.org/html/rfc6191#page-3&quot;&gt;RFC6191&lt;/a&gt;提出使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_timestamps&quot;&gt;TCP Timestamp&lt;/a&gt;来减少这样的TIME_WAIT状态。&lt;/p&gt;

&lt;p&gt;在内核中的代码实现如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;c&quot;&gt;536 bool tcp_peer_is_proven(struct request_sock *req, struct dst_entry *dst, bool paws_check)
537 {
538         struct tcp_metrics_block *tm;
539         bool ret;
540
541         if (!dst)
542                 return false;
543
544         rcu_read_lock();
545         tm = __tcp_get_metrics_req(req, dst);
546         if (paws_check) {
547                 if (tm &amp;amp;&amp;amp;
548                     (u32)get_seconds() - tm-&amp;gt;tcpm_ts_stamp &amp;lt; TCP_PAWS_MSL &amp;amp;&amp;amp;
549                     (s32)(tm-&amp;gt;tcpm_ts - req-&amp;gt;ts_recent) &amp;gt; TCP_PAWS_WINDOW)
550                         ret = false;
551                 else
552                         ret = true;
553         } else {
554                 if (tm &amp;amp;&amp;amp; tcp_metric_get(tm, TCP_METRIC_RTT) &amp;amp;&amp;amp; tm-&amp;gt;tcpm_ts_stamp)
555                         ret = true;
556                 else
557                         ret = false;
558         }
559         rcu_read_unlock();
560
561         return ret;
562 }
563 EXPORT_SYMBOL_GPL(tcp_peer_is_proven);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在代码中，547-552行主要确保在TCP_PAWS_MSL时间内请求的时间戳是递增的(TCP_PAWS_WINDOW为1)。&lt;/p&gt;

&lt;h3&gt;ipatbles NAT&lt;/h3&gt;

&lt;p&gt;所以当后端机器在NAT后面时，由于NAT并没有改时间戳，连接中的时间戳来自不同的机器，时间戳(机器启动时间)不一定是递增的，所以就会出现后端机器drop SYN包的情况.&lt;/p&gt;

&lt;p&gt;在NAT后的机器，关闭tcp_tw_recycle检查即可，一般该选项为disable的。&lt;/p&gt;

&lt;h3&gt;参考材料&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://lxr.free-electrons.com/source/net/ipv4/tcp_metrics.c?v=3.10#L536&quot;&gt;http://lxr.free-electrons.com/source/net/ipv4/tcp_metrics.c?v=3.10#L536&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6191#page-3&quot;&gt;https://tools.ietf.org/html/rfc6191#page-3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/&quot;&gt;http://www.isi.edu/touch/pubs/infocomm99/infocomm99-web/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#summary&quot;&gt;https://vincent.bernat.im/en/blog/2014-tcp-time-wait-state-linux.html#summary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc1323.txt&quot;&gt;https://www.ietf.org/rfc/rfc1323.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>flannel vxlan implementation</title>
   <link href="http://wangtaox.github.io/2016/07/29/flannel-vxlan.html"/>
   <updated>2016-07-29T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/07/29/flannel-vxlan</id>
   <content type="html">&lt;p&gt;flannel是&lt;a href=&quot;https://coreos.com/&quot;&gt;coreos&lt;/a&gt;为&lt;a href=&quot;http://kubernetes.io/&quot;&gt;kubernets&lt;/a&gt;提供的网络解决方案，主要为打通跨节点的容器通信，其中vxlan模式为flannel实现的一种后端模式，其他模式还包括&lt;strong&gt;udp&lt;/strong&gt;,
&lt;strong&gt;host-gw&lt;/strong&gt;等，可以通过&lt;a href=&quot;https://github.com/coreos/flannel&quot;&gt;flannel&lt;/a&gt;官网了解更多信息。&lt;/p&gt;

&lt;h3&gt;linux vxlan工作原理&lt;/h3&gt;

&lt;p&gt;flannel的vxlan模式使用的是原生的linux vxlan实现，因此了解linux vxlan工作原理对于理解flannel的代码实现很有帮助。&lt;/p&gt;

&lt;p&gt;在linux vxlan中，主要术语:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;L3 Miss: 目标IP在邻居表中未找到 (IP Miss，所以才叫L3 Miss吗？)&lt;/li&gt;
&lt;li&gt;L2 Miss: 目标MAC在vxlan FDB中未找到对应项 (2层的Miss)&lt;/li&gt;
&lt;li&gt;NOLEARNING: 禁止洪泛数据包 (在FDB中未找到相应表项)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;&lt;strong&gt;vxlan fdb&lt;/strong&gt; 主要映射目标MAC到vtep IP。&lt;/p&gt;

&lt;p&gt;如图 &lt;img src=&quot;/media/files/2016/08/01/linux_vxlan.svg&quot; alt=&quot;flannel-ovs&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;创建vxlan device
$ip link add vxlan0 type vxlan id 42 group 239.1.1.1 dev eth0
$ip link set vxlan0 address 54:8:20:0:0:A
$ip address add 10.10.10.1 dev vxlan0
$ip link set up vxlan0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;host－A 10.10.10.1 ping host-B 10.10.11.1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;Host-A $ping 10.10.11.1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;host-A vxlan0接口生成arp请求10.10.11.1的mac地址&lt;/li&gt;
&lt;li&gt;vxlan 驱动封装添加VNI header，没有已知的目的mac，使用多播地址&lt;/li&gt;
&lt;li&gt;eth0 发出数据包&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;在host－B上，&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;host－B收到数据包然后转发给相应的udp端口(vxlan)&lt;/li&gt;
&lt;li&gt;vxlan驱动解封装，vxlan0接收到arp request包，并生成相应的arp reply包，添加相应的vxlan header，目的mac为56:bb:01:0f:cb:A&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;这样在host-B的fdb中，会学到56:bb:01:0f:cb:A到转发规则，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;Host-B $bridge fdb show dev vxlan0
56:bb:01:0f:cb:A dev vxlan0 dst 192.168.1.10 self
0:0:0:0:0:0 dev vxlan0 dst 239.1.1.1 via eth0 self permanent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二条规则就是在目的mac为止时使用多播地址的相应规则。&lt;/p&gt;

&lt;h3&gt;flannel实现方式&lt;/h3&gt;

&lt;p&gt;因为flannel是为k8s提供的网络解决方案，而在k8s中，每一台host会分配一个网段，该网段所有启动的容器均在这台机器上，所以，对于flnanel来说，很多信息都是已知的，可以简化flannel的vxlan fdb(不需要处理未知的MAC地址情况)以及相应的代码实现。&lt;/p&gt;

&lt;p&gt;在flannel中，flannel会在每一台启动了flannel agentd的机器上创建一个vxlan device(上述的vxlan0)，名称是flannel.1(1为vni号)，flannel agent会根据分配的网段信息和vxlan device信息(vxlan device的mac地址)，动态的修改host上的邻居表，并结合vxlan device的fdb实现跨主机的docker容器的通信。&lt;/p&gt;

&lt;h4&gt;一个例子&lt;/h4&gt;

&lt;p&gt;flannel的网段分配信息是通过etcd 记录的，在etcd中设置相应信息:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;etcd $etcdctl get /flannel/network/config
{ &quot;Network&quot;: &quot;10.10.0.0/16&quot;, &quot;Backend&quot;: { &quot;Type&quot;: &quot;vxlan&quot;, &quot;VNI&quot;: 1 } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在host-A上运行flannel agent，agent在etcd中分配网段10.10.10.0/24，agent创建flannel.1设备接口，配置IP 10.10.10.0 MAC 56:bb:01:0f:cb:A，配置路由，整个大段通过flannel.1, 这样overlay网络流量通过flannel.1转发处理，然后启动docker0，通过指定bip 10.10.10.1/24启动，这样在host-A上的容器使用网段10.10.10.1/24。&lt;/p&gt;

&lt;p&gt;同理在host-B上运行flannel agent，agent进行的相应配置过程类似。&lt;/p&gt;

&lt;p&gt;整个例子如图&lt;img src=&quot;/media/files/2016/08/01/flannel-vxlan.svg&quot; alt=&quot;flannel-vxlan&quot; /&gt;&lt;/p&gt;

&lt;h4&gt;flannel vxlan相应工作流程&lt;/h4&gt;

&lt;p&gt;由于flannel agentd知道所有的网段分配信息以及每台host上的flannel.1设备的IP，MAC，因此每一个网段在进行vxlan fdb转发时，可以使用host上flannel.1的MAC地址。&lt;/p&gt;

&lt;p&gt;在host-A上，运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host-A# bridge fdb show dev flannel.1
56:bb:01:0f:cb:B dst 192.168.1.11 self permanent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在host－B上，运行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;host-B# bridge fdb show dev flannel.1
56:bb:01:0f:cb:A dst 192.168.1.10 self permanent
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如图c1 ping c2时，如果容器c1 IP(10.10.10.2), 容器c2 IP(10.10.11.2),
因为host－A 的邻居表里没有c2 IP到MAC表项，flannel agent会收到相应的l3 miss(netlink)消息，然后flannel agent会反应式的设置c2 的IP到MAC表项为10.10.11.2-56:bb:01:0f:cb:B，这样在fdb中MAC 56:bb:01:0f:cb:B就对应到host-B的flannel.1。&lt;/p&gt;

&lt;p&gt;因为flannel知道必要的网络信息，所以flannel直接按段处理了L3 miss的消息，L2的fdb直接在启动时根据etcd信息静态配置好，这样整个网络就连通了。&lt;/p&gt;

&lt;h4&gt;L3 miss代码&lt;/h4&gt;

&lt;p&gt;如代码，在L3 miss代码中，通过miss的IP在所有段里匹配然后设置对应的vtepMac，即:
上述的c2 IP是对应到网段10.10.11.0/24的，然后相应的vtepMAC就对应到host-B的flannel.1的MAC，代码中是通过路由信息记录的，也保存了设备的MAC。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;golang&quot;&gt;func (n *network) handleL3Miss(miss *netlink.Neigh) {
    log.Infof(&quot;L3 miss: %v&quot;, miss.IP)

    rt := n.rts.findByNetwork(ip.FromIP(miss.IP))
    if rt == nil {
        log.Infof(&quot;Route for %v not found&quot;, miss.IP)
        return
    }

    if err := n.dev.AddL3(neigh{IP: ip.FromIP(miss.IP), MAC: rt.vtepMAC}); err != nil {
        log.Errorf(&quot;AddL3 failed: %v&quot;, err)
    } else {
        log.Info(&quot;AddL3 succeeded&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;L2的代码也可以在该函数&lt;a href=&quot;https://github.com/coreos/flannel/blob/master/backend/vxlan/network.go&quot;&gt;所在文件&lt;/a&gt;中找到。&lt;/p&gt;

&lt;h4&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://events.linuxfoundation.org/sites/events/files/slides/2013-linuxcon.pdf&quot;&gt;http://events.linuxfoundation.org/sites/events/files/slides/2013-linuxcon.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://lartc.org/howto/lartc.kernel.obscure.html&quot;&gt;http://lartc.org/howto/lartc.kernel.obscure.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hustcat.github.io/vxlan-l3miss-problem/&quot;&gt;http://hustcat.github.io/vxlan-l3miss-problem/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>max-width和width</title>
   <link href="http://wangtaox.github.io/2016/07/08/max-width-and-width.html"/>
   <updated>2016-07-08T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/07/08/max-width-and-width</id>
   <content type="html">&lt;p&gt;以下max-width及width使用方式区别:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.modal-one {
    ...
    width: 800px;
    max-width: 100%;
}

or

.modal-two {
    ...
    width: 100%;
    max-width: 800px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Scenario 1: parent is wider than 800px&lt;/h4&gt;

&lt;p&gt;parent is 1000px wide&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.modal-one&lt;/code&gt; 显示width为800px, max-width为1000px, width未超过max-width, 则width最终为800px&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.modal-two&lt;/code&gt; 显示width为1000px, max-width为800px, width超过了max-width, 则width最终为800px&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;Scenario 2: parent is smaller than 800px&lt;/h4&gt;

&lt;p&gt;parent is 460px wide&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.modal-one&lt;/code&gt; 显示width为800px, max-width为460px, width超过max-width, 则width最终为460px&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.modal-two&lt;/code&gt; 显示width为460px, max-width为800px, width未超过max-width, 则width最终为460px&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;因此, 一个元素如果width大于max-width, max-width是高于width的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>&quot;CSS secrets&quot; Reading Notes</title>
   <link href="http://wangtaox.github.io/2016/05/14/css-secret-reading-notes.html"/>
   <updated>2016-05-14T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/05/14/css-secret-reading-notes</id>
   <content type="html">&lt;h3&gt;currentColor&lt;/h3&gt;

&lt;p&gt;In css3, we got a special new color keyword &lt;strong&gt;currentColor&lt;/strong&gt;, which always resolves to the value of the &lt;strong&gt;color&lt;/strong&gt; property, make it &lt;strong&gt;the first ever variable&lt;/strong&gt; in css.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.dont-do-this {
  height: 2em;
  width: 1em;
  background: currentColor;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It will become even more useful when we get functions to manipulate colors in native css.&lt;/p&gt;

&lt;h3&gt;Use shorthands wisely&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.positive-bg {
  background: blue;
  /*background-color: blue;*/
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is good defensive coding and future-proofing to use them, unless we intentionally want to use cascaded properties.&lt;/p&gt;

&lt;h3&gt;background-clip&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;CSS&quot;&gt;.photo-box {
  border: .4em solid rgba(255, 255, 255, .5);
  border-radius: .4em;
  font-size: 120%;
  line-height: 1.5;
  width: 720px;
  background: rgba(255, 255, 255);
  background-clip: padding-box;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;outline&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;outline&lt;/strong&gt; do not fellow the elements’s rounding but &lt;strong&gt;box-shadow&lt;/strong&gt; do&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.box {
  background: blue;
  border-radius: .8em;
  padding: 1em;
  box-shadow: 0 0 0 .8em red;
  outline: .8em solid red;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;linear-gradient&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.bg {
  background: linear-gradient(red 20%, blue 80%);
  ....
  /* 80% － 20% is the length of gradient area */
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we set the color position at 0, it means its position is set to where the previous one stop.&lt;/p&gt;

&lt;h3&gt;box-shadow&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.box {
  box-shadow: 0 0 10px blue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;z-index&lt;/h3&gt;

&lt;p&gt;First of all, z-index only works on positioned elements. If you try to set a z-index on an element with no position specified, it will do nothing. Secondly, z-index values can create stacking contexts.&lt;/p&gt;

&lt;p&gt;Every stacking context has a single HTML element as its root element. When a new stacking context is formed on an element, that stacking context confines all of its child elements to a particular place in the stacking order, That means that if an element is contained in a stacking context at the bottom of the stacking order, there is no way to get it to appear in front of another element in a different stacking context that is higher in the stacking order, even with a z-index of a billion!&lt;/p&gt;

&lt;p&gt;New stacking contexts can be formed on an element in one of three ways:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;When an element is the root element of a document (the &lt;strong&gt;html&lt;/strong&gt; element)&lt;/li&gt;
&lt;li&gt;When an element has a position value other than static and a z-index value other than auto&lt;/li&gt;
&lt;li&gt;When an element has an opacity value less than 1&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;In addition to opacity, several newer CSS properties also create stacking contexts. These include: transforms, filters, css-regions, paged media, and possibly others. As a general rule, it seems that if a CSS property requires rendering in an offscreen context, it must create a new stacking context.&lt;/p&gt;

&lt;p&gt;Here are the basic rules to determine stacking order within a single stacking context (from back to front):&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The stacking context’s root element&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with negative z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Non-positioned elements (ordered by appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with a z-index value of auto (ordered by appearance in the HTML)&lt;/li&gt;
&lt;li&gt;Positioned elements (and their children) with positive z-index values (higher values are stacked in front of lower values; elements with the same value are stacked according to appearance in the HTML)&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Note: positioned elements with negative z-indexes are ordered first within a stacking context, which means they appear behind all other elements. Because of this, it becomes possible for an element to appear behind its own parent, which is normally not possible. This will only work if the element’s parent is in the same stacking context and is not the root element of that stacking context.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>&quot;flip&quot;动画</title>
   <link href="http://wangtaox.github.io/2016/03/28/flip.html"/>
   <updated>2016-03-28T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/03/28/flip</id>
   <content type="html">&lt;h3&gt;flip动画&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;first: 元素在动画中的初始状态&lt;/li&gt;
&lt;li&gt;last: 元素的动画的结束状态&lt;/li&gt;
&lt;li&gt;invert: 计算first和last状态的差值，然后设置相应的属性(transform, opacity等)，使元素在初始状态。&lt;/li&gt;
&lt;li&gt;play: 触发整个动画&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;一个例子🌰&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;head&amp;gt;
  &amp;lt;style media=&quot;screen&quot;&amp;gt;
    body {
    }

    .container {
      width: 100%;
      height: 100%;
      margin: 0 auto;
      background: #BBDEFB;
      position: relative;
    }

    .circle {
      width: 100px;
      height: 100px;
      border-radius: 100%;
      background-color: #E1BEE7;
      position: absolute;
      top: 10px;
      left: 10px;
    }

    .circle-end {
      top: auto;
      left: auto;
      bottom: 10px;
      right: 10px;
    }

  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
  &amp;lt;button type=&quot;button&quot; name=&quot;button&quot; onclick=&quot;doAnimate()&quot;&amp;gt;Animate&amp;lt;/button&amp;gt;
  &amp;lt;div class=&quot;container&quot;&amp;gt;
    &amp;lt;div class=&quot;circle&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
  function doAnimate() {
    var node = document.getElementsByClassName(&#39;circle&#39;)[0]

    //计算初始属性
    var first = node.getBoundingClientRect()
    node.classList.add(&#39;circle-end&#39;)
    //计算结束属性
    var last = node.getBoundingClientRect()

    //invert
    var invertX = first.left - last.left
    var invertY = first.top - last.top

    node.style.transform = &#39;translate(&#39; + invertX + &#39;px,&#39; + invertY + &#39;px)&#39;
    node.style.transition = &#39;transform 0s&#39;

    requestAnimationFrame(function(node) {
      return function() {

        //触发动画
        node.style.transition = &#39;all 1s&#39;;
        node.style.transform  = &#39;&#39;;
        console.log(node)
      }
    }(node))
  }

  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;requestAnimationFrame函数&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame&quot;&gt;requestAnimationFrame&lt;/a&gt;函数主要告诉浏览器在重绘每一帧动画时，可以运行用户定义的代码，可以进行相应的计算等等。&lt;/p&gt;

&lt;h4&gt;参考资料&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/developers-writing/animating-the-unanimatable-1346a5aab3cd#.86itpf3ga&quot;&gt;Animating the Unanimatable.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aerotwist.com/blog/flip-your-animations/&quot;&gt;FLIP Your Animations&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>理解javascript promise</title>
   <link href="http://wangtaox.github.io/2016/03/04/promise.html"/>
   <updated>2016-03-04T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/03/04/promise</id>
   <content type="html">&lt;h3&gt;so promise ？&lt;/h3&gt;

&lt;p&gt;promise，翻译过来就是承诺的意思，在javascript中，promise是一个关于异步操作的结果的“承诺”,
可以在&lt;a href=&quot;https://promisesaplus.com/&quot;&gt;promise A+ spec&lt;/a&gt;中了解更多关于promise的信息。&lt;/p&gt;

&lt;p&gt;在此翻译了pouchdb中关于promise的博客，以加深对promise的理解。&lt;a href=&quot;https://twitter.com/nolanlawson&quot;&gt;作者&lt;/a&gt;在推上发了一段关于promise的代码，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//case 1
doSomething().then(function() {
    return doSomethingElse()
})
//case 2
doSomething().then(function() {
    doSomethingElse()
})
//case 3
doSomething().then(doSomethingElse())
//case 4
doSomething().then(doSomethingElse)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意: &lt;code&gt;doSomething&lt;/code&gt;及&lt;code&gt;doSomethingElse&lt;/code&gt;都是一个函数并返回新的promise.&lt;/p&gt;

&lt;p&gt;知道几个case的区别么? #@!...以下代码可能会使用一些ES6语法。&lt;/p&gt;

&lt;h3&gt;坑1: 回调金字塔&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then((resultOfUsers) =&amp;gt; {
    resultOfUsers.forEach((user) =&amp;gt; {
        localStorageWithPromise.put(user).then(() =&amp;gt; {
            console.log(`put user ${user.name} to localStorage success!`)
        }).catch((err) =&amp;gt; {
            console.log(`put user ${user.name} to localStorage failed!`)
            localStorageWithPromise.remove(user.id).then(() =&amp;gt; {
                console.log(`remove possible user info with user id : ${user.id}`)
            })
            ...
        })
    })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样当我们需要完成更复杂的一些回调操作时，可能代码比这还嵌套得深，这样代码的可读性以及可维护性就会很糟糕，而更好的书写
方式应该这样，称为&lt;code&gt;组合promise&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    return Promise.all(resultOfUsers.forEach((user) =&amp;gt; {
        return localStorageWithPromise.put(user)
    }))
}).then((resultInfo) =&amp;gt; {
    console.log(`put result ${resultInfo}`)
}).catch((err) =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更直观一点，或许我们应该组织我们的promise调用链如下面这样的方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;operationA().then((resultOfA) =&amp;gt; {
    return doWithResultA(resultOfA)
}).then((resultFromA) =&amp;gt; {
    return operationB(resultFromA)
}).then((resultFromB) =&amp;gt; {
    return operationC(resultFromB)
}).catch(err =&amp;gt; {
    console.log(`any errors &quot;${err}&quot; happened in promise chain`)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样整个调用链会比较清晰，且可以统一的&lt;code&gt;catch&lt;/code&gt;错误并处理。&lt;/p&gt;

&lt;h3&gt;坑2: forEach与promise&lt;/h3&gt;

&lt;p&gt;比如如下的操作:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    resultOfUsers.forEach(user =&amp;gt; {
        user.remove()
    })
}).then(() =&amp;gt; {
    //以为已经删除了所有用户
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多时候我们以为这样写就可以了，其实是错误的，第二个then回调并不会等待所有user被删除才执行，因为在第一个then回调中，函数返回
的是&lt;code&gt;undefined&lt;/code&gt;, 所以这样的写法就会存在bug, 正确的写法应该如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUsersFromRESTAPI().then(resultOfUsers =&amp;gt; {
    return Promise.all(resultOfUsers.forEach(user =&amp;gt; {
        return user.remove()
    }))
}).then(() =&amp;gt; {
    console.log(&quot;all users has been deleted.&quot;)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在第一个then回调中返回了promise，并使用了&lt;code&gt;promise.all&lt;/code&gt;, 注意&lt;code&gt;user.remove&lt;/code&gt;也是返回promise的。&lt;/p&gt;

&lt;h3&gt;坑3: 忘记catch错误&lt;/h3&gt;

&lt;p&gt;我们不应该去假设我们的promise不返回任何错误，应该在promise调用中都进行正确的错误处理.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return opReturnPromise2()
}).then(() =&amp;gt; {
    return opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;promise中的返回值&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    opReturnPromise2()
}).then(() =&amp;gt; {
    opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有什么问题么？这儿在promise的回调中&lt;code&gt;返回值存在问题&lt;/code&gt;, 在promise中，then()回调可以返回:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;返回另一个promise.&lt;/li&gt;
&lt;li&gt;返回一个值(或者undefined).&lt;/li&gt;
&lt;li&gt;返回一个错误.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;返回另一个promise&lt;/h4&gt;

&lt;p&gt;这就是上面提到的&lt;code&gt;组合promise&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return opReturnPromise2()
}).then(() =&amp;gt; {
    return opReturnPromise3()
}).catch(err =&amp;gt; {
    //handle errors properly.
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;返回一个值(或者undefined)&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUserFromRESTAPI(userName).then((userInfo) =&amp;gt; {
    if (FriendsCache[userInfo.id]) {
        return FriendsCache[userInfo.id]
    }
    return getUserFriends(userInfo.id)
}).then((friends) =&amp;gt; {
    console.log(friends)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写是不是很清晰，在第二个处理friends的then回调中，我不需要关心friends是在cache中还是从API中获取的，处理得到的好友列表即可。
由于在javascript中，函数不显视的返回任何值，则返回undefined，所有在promise的then回调中，建议总是返回一个值或者抛出错误。&lt;/p&gt;

&lt;h4&gt;返回一个错误&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;getUserFromRESTAPI(userName).then((userInfo) =&amp;gt; {
    if (isLoggedout(userInfo.id)) {
        throw new Error(&quot;logged out!&quot;)
    }
    if (FriendsCache[userInfo.id]) {
        return FriendsCache[userInfo.id]
    }
    return getUserFriends(userInfo.id)
}).then((friends) =&amp;gt; {
    console.log(friends)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;巧用Promose.resolve&lt;/h3&gt;

&lt;p&gt;使用promise包装同步的代码使其异步化，并进行错误处理。对于同步的操作，promise也可以提供很多帮助，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let caculateSomethingAndMayThrowError  = (x, y) =&amp;gt; {
    if (x &amp;lt; y) {
        throw new Error(&quot;x &amp;lt; y&quot;)
    }
    return x - y
}

let wrapAPI2Promise = () =&amp;gt; {
    return Promise.resolve().then(() =&amp;gt; {
        let value = caculateSomethingAndMayThrowError()
        return value
    }).then((value) =&amp;gt; {
        console.log(value)
    }).catch((err) =&amp;gt; {
        console.log(err)
    })
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在catch中我们可以处理同步函数抛出的异常.&lt;/p&gt;

&lt;h3&gt;避免reject函数，使用catch&lt;/h3&gt;

&lt;p&gt;catch函数其实是一个语法糖, 如下所示:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().catch((err) =&amp;gt; {})
//equal to
promise1().then(null, (err) =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是如下的代码却并不一样，如下:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;promise1().then(() =&amp;gt; {
    return promise2()
}).catch((err) =&amp;gt; {
    console.log(err)
})

promise1().then(() =&amp;gt; {
    return promise2()
}, (err) =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一个catch会处理整个promise链中的异常错误，但是第二个却是处理promise1的异常错误，因为它相当于promise1的reject函数。
所以一般情况下建议只用catch函数，避免给then传递第二个参数导致理解错误，出现bug。&lt;/p&gt;

&lt;h3&gt;promise工厂函数&lt;/h3&gt;

&lt;p&gt;有时可以通过工厂函数，组合我们的promise链，但是一定要注意返回值, 例如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//依次sleep 1s

let suspendOneSecondFactory = () =&amp;gt; {
    return () =&amp;gt; {
        return new Promise((resolve, reject) =&amp;gt; {
            setTimeout(() =&amp;gt; {
                console.log(&#39;sleep 1s&#39;)
                resolve()
            }, 1000)
        })
    }
}

let result = Promise.resolve()
[1, 2, 3].forEach(() =&amp;gt; {
    result = result.then(suspendOneSecondFactory())
})
result.then(() =&amp;gt; {
    console.log(&quot;the end&quot;)
}).catch(err =&amp;gt; {
    console.log(err)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;promise在使用时一定要注意then回调的返回值，以及组合使用promise，并将操作尽量步骤化，那样可以使用proise链组合出各种需要的
依赖链并进行调用, 如果给then调用传递非函数值，在then调用中传递的非函数值会被解析为null。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>React lifecycle hooks notes</title>
   <link href="http://wangtaox.github.io/2016/02/25/react-lifecycle.html"/>
   <updated>2016-02-25T14:42:35+08:00</updated>
   <id>http://wangtaox.github.io/2016/02/25/react-lifecycle</id>
   <content type="html">&lt;h3&gt;Component Life Cycle Hooks&lt;/h3&gt;

&lt;p&gt;React provides a series of life cycle hooks we can tap into each phase of the life cycle, each of the life cycle hooks are called in specific order and at a specific time.&lt;/p&gt;

&lt;h4&gt;component创建&lt;/h4&gt;

&lt;p&gt;组件的创建主要步骤包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;component初始化&lt;/li&gt;
&lt;li&gt;component.defaultProps获取component的props&lt;/li&gt;
&lt;li&gt;this.state = ...(ES6的class constructor函数)&lt;/li&gt;
&lt;li&gt;componentWillMount()函数&lt;/li&gt;
&lt;li&gt;render()函数&lt;/li&gt;
&lt;li&gt;子组件的初始化以及生命周期函数&lt;/li&gt;
&lt;li&gt;componentDidMount()函数&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;注意传递props时的null值，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;//right
&amp;lt;Box name={null}&amp;gt; //pass null to props is tricky

//wrong
&amp;lt;Box name={undefined}&amp;gt;

class Box extends React.Componets {
  constructor(props) {
    super(props);
    this.state = { open: false };
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意在constructor函数中需要给state赋值，不然this.state就是undefined了.&lt;/p&gt;

&lt;p&gt;当props和state都设置好后，就会进入第一个生命周期函数componentWillMount，记住在该函数中Dom还未mount，因此访问
this.refs是不允许的，在该函数中我们可以为调整state或者为第一次render做一些前期工作，比如注册一些全局的事件(window.resize)。&lt;/p&gt;

&lt;p&gt;It&#39;s important to remember that many Native UI elements do not exist at this point in the life cycle. That means we need to stick to very high-level/global events such as window or document.&lt;/p&gt;

&lt;p&gt;在render函数中，我们根据props和state对组件进行渲染，因此，render应该是一个pure function，componentUI = render(props, state)，在render就不应该调用setState函数了，同时也不应该在render中操作DOM.&lt;/p&gt;

&lt;p&gt;有子组件存在时，渲染子组件，类似DFS？&lt;/p&gt;

&lt;p&gt;在componentDidMount函数中，我们可以访问Native UI了，所以在该函数中根据UI进行一些操作时可以的，比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;componentDidMount() {
  this.chart = highcharts.Highcharts({
    elem: this.refs.chart,
    ...
  });

  this.table = DataTable.Table({
    ...
  });

  $(.css_class).xxx();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;component更新&lt;/h4&gt;

&lt;p&gt;组件的更新主要步骤包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;componentWillReceiveProps()函数&lt;/li&gt;
&lt;li&gt;shouldComponentUpdate()函数&lt;/li&gt;
&lt;li&gt;render()函数&lt;/li&gt;
&lt;li&gt;子组件的生命周期函数&lt;/li&gt;
&lt;li&gt;componentWillUpdate()函数&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;componentWillReceiveProps(nextProps)函数会在props传递给component时调用，可以对比props。&lt;/p&gt;

&lt;p&gt;The core issue with props and componentWillReceiveProps() is how JavaScript provides mutable data structures. Let&#39;s say we have a prop called data and data is an Array.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// psuedo code
this.setState({ data: [1, 2, 3] });

&amp;lt;MyComponent data={ this.state.data } /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js中Object时引用的，因此在React中要格外注意。&lt;/p&gt;

&lt;p&gt;The next method in the Update life cycle, is shouldComponentUpdate(). This method allows your Component to exit the Update life cycle if there is no reason to apply a new render. Out of box, the shouldComponentUpdate() is a no-op that returns true. This means every time we start an Update in a Component, we will re-render.
If you recall, React does not deeply compare props by default. When props or state is updated React assumes we need to re-render the content. But, if the props or state have not changed, should we really be re-rendering?&lt;/p&gt;

&lt;p&gt;Once we have determined that we do need to re-render in our Update phase, the componentWillUpdate() will be called. The method is passed in two arguments: nextProps and nextState. The method componentWillUpdate() is similar to componentWillMount(), and many of the same considerations and tasks are the same. The difference being that componentWillUpdate() is called every time a re-render is required and we get access to the next props and state.&lt;/p&gt;

&lt;p&gt;Just like componentWillMount(), this method is called before render(). Because we have not rendered yet, our Component&#39;s access to the Native UI (DOM, etc.) will reflect the old rendered UI. Unlike, componentWillMount() we can technically access refs but it is not recommended because the refs will also be out of date.+&lt;/p&gt;

&lt;p&gt;The componentWillUpdate() is a chance for us to handle configuration changes, update our state and in general prepare for the next render. If we want to access the old props or state, we can call this.props or this.state. We can then compare them to the new values and make changes/calculations as required.&lt;/p&gt;

&lt;p&gt;Continuing the trend of corresponding methods, the componentDidUpdate() is the Update version of componentDidMount(). Once again, we can access the Native UI stack, interact with our refs and if required start another re-render/update.&lt;/p&gt;

&lt;p&gt;When componentDidUpdate() is called, two arguments are passed: prevProps and prevState. This is the inverse of componentWillUpdate(). The passed values are what the values were and accessing this.props and this.state are the current values&lt;/p&gt;

&lt;p&gt;The most common uses of componentDidUpdate() is managing 3rd party UI elements and interacting with the Native UI. When using 3rd Party libraries, like our Chart example, we need to update the UI library with new data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;componentDidUpdate(prevProps, prevState) {
  // only update chart of the data has changed
  if (prevProps.data !== this.props.data) {
    this.chart = c3.load({
      data: this.props.data
    });
  }
}

//Another render pass?
componentDidUpdate(prevProps, prevState) {
  // One possible fix...
  let height = ReactDOM.findDOMNode(this).offsetHeight;
  if (this.state.height !== height ) {
    this.setState({ internalHeight: height });
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;component挂载&lt;/h4&gt;

&lt;p&gt;组件的卸载和清楚步骤包括:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;componentWillUnmount()&lt;/li&gt;
&lt;li&gt;子组件生命周期函数&lt;/li&gt;
&lt;li&gt;component GC&lt;/li&gt;
&lt;/ol&gt;


&lt;p&gt;Just like the rest of our life cycle phases, the Death/Unmount phase has a method hook for us. This method allows us to do some cleanup before we are removed from the UI stack. Typically we want to reverse any setup we did in either componentWillMount() or componentDidMount().&lt;/p&gt;

&lt;p&gt;For example, we would want to unregister any global/system/library events, destroy 3rd party UI library elements, etc. If we don&#39;t take the time to remove events we can create memory leaks in our system or leave bad references laying around.&lt;/p&gt;

&lt;h4&gt;redux&lt;/h4&gt;

&lt;p&gt;redux reducer, 根据action和state得出新的state， (prevState, action) =&gt; newState, 和我们熟悉的Array.prototype.reduce(reducer, prevValue)类似&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let initiaState = { count: 0 }

//counter example
let actions = [
    {type: &#39;INC&#39;},
    {type: &#39;DEC&#39;},
]

//take actions and state as paramaters, output new state.
function counterReducer(state = initiaState, action) {
    switch(action.type) {
        case &#39;INC&#39;:
            return Object.assign({}, state, {
                count: state.count++
            })
        case &#39;DEC&#39;:
            return Object.assign({}, state, {
                count: state.count--
            })
        default:
            return initiaState
    }
}
console.log(actions.reduce(counterReducer, initiaState))
&lt;/code&gt;&lt;/pre&gt;
</content>
 </entry>
 
 <entry>
   <title>golang grpc学习</title>
   <link href="http://wangtaox.github.io/2016/02/01/grpc.html"/>
   <updated>2016-02-01T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2016/02/01/grpc</id>
   <content type="html">&lt;h3&gt;grpc简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.grpc.io/&quot;&gt;grpc&lt;/a&gt;是Google开源的rpc框架，使用&lt;a href=&quot;https://developers.google.com/protocol-buffers/&quot;&gt;protobuf&lt;/a&gt;进行数据编码，，基于Http2协议，提供了很多优势，比如:双向的数据流，流控制，包头压缩，多路复用等，详细信息可以参考grpc官网。&lt;/p&gt;

&lt;h3&gt;protobuf3&lt;/h3&gt;

&lt;p&gt;protobuf是Google提供的一个跨语言的数据编码机制，支持多种语言，在结合RPC使用时，可以节省带宽，提高传输效率，grpc提供了protobuf的相应工具，这样就可以使用proto文件定义RPC接口，约定传输数据格式，通过生成工具生成相应语言的源文件。&lt;/p&gt;

&lt;h3&gt;定义一个文件传输服务&lt;/h3&gt;

&lt;p&gt;以下为一个文件服务的proto文件定义, file.proto :&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;protocol&quot;&gt;syntax ＝ &quot;proto3&quot;;

package filetransfer;

//rpc调用定义
service FileServer {
  rpc GetFile(FileDescriptor) returns (stream FileContent) {}
}

message FileDescriptor {
  string filename = 1;
}

message FileContent {
  bytes content = 1;
  string md5sum = 2;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过工具生成相应语言源代码，以&lt;a href=&quot;http://golang.org&quot;&gt;golang&lt;/a&gt;为例，使用如下命令:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;protoc --go_out=plugins=grpc:. file.proto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是服务端的代码实现:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;const (
  BUFSIZE = 1024
)

func (am *AgentManager) GetFile(fd *pb.FileDescriptor, stream pb.FileServer_GetFileServer) error {
  filename := fd.Filename

  //make sure file existed.
  fo, err := os.Open(filename)
  if err != nil {
    return ErrNoSuchFile
  }
  defer func() {
      if err := fo.Close(); err != nil {
        panic(err)
      }
  }()

  content := &amp;amp;pb.FileContent {
    Content: make([]byte, BUFSIZE),
    Md5Sum: caculateMd5(filename),
  }
  for {
    n, err := fo.Read(content.Content)
    if err != nil &amp;amp;&amp;amp; err != io.EOF {
      return ErrReadFile
    }
    if n == 0 {
      break
    }

    if err := stream.Send(content); err != nil {
      return err
    }
  }

  //indicate the end of stream.
  return nil
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下是Client端代码:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;go&quot;&gt;
func ReadFile(filename string, conn pb.FileServerClient) error {
  stream, err := conn.GetFile(filename)
  if err != nil {
    panic(err)
  }

  outFd, err := os.Create(filename)
  if err != nil {
    panic(err)
  }
  defer func() {
      if err := outFd.Close(); err != nil {
        panic(err)
      }
  }()

  for {
    content, err := stream.Recv()
    if err == io.EOF {
      break
    }
    if err != nil {
      panic(err)
    }

    if err := outFd.Write(content.Content); err != nil {
      panic(err)
    }
  }

  return nil
}


func checkMd5(filename string, md5 string) bool {
  return caculateMd5(filename) == md5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码有部分省略.&lt;/p&gt;

&lt;h3&gt;grpc stream&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;protobuf&quot;&gt;syntax = &quot;proto3&quot;;

package chatservice;

service chatservice {
  //双向的stream
  rpc chat(stream ChatMessage) returns (ChatMessage) {}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;grpc的stream可以是双向的也可以是单向的，在通过proto文件定义时指定，比如: 也可以实现如Chat这样的接口。&lt;/p&gt;

&lt;h3&gt;参考链接&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://talks.golang.org/2015/gotham-grpc.slide#1&quot;&gt;http://talks.golang.org/2015/gotham-grpc.slide#1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://coreos.com/blog/gRPC-protobufs-swagger.html&quot;&gt;https://coreos.com/blog/gRPC-protobufs-swagger.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/coreos/etcd/blob/master/etcdserver/etcdserverpb/rpc.proto&quot;&gt;https://github.com/coreos/etcd/blob/master/etcdserver/etcdserverpb/rpc.proto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gengo/grpc-gateway&quot;&gt;https://github.com/gengo/grpc-gateway&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>openstack rpc实现源码分析</title>
   <link href="http://wangtaox.github.io/2015/11/21/rpc.html"/>
   <updated>2015-11-21T00:00:00+08:00</updated>
   <id>http://wangtaox.github.io/2015/11/21/rpc</id>
   <content type="html">&lt;h3&gt;RabbitMQ的消息模型&lt;/h3&gt;

&lt;h4&gt;RabbitMQ 基本概念:&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;Producer: 消息生产者&lt;/li&gt;
&lt;li&gt;Consumer: 消息消费者&lt;/li&gt;
&lt;li&gt;Exchange: 接受消息的载体&lt;/li&gt;
&lt;li&gt;Message: RabbitMQ中的基本消息单元&lt;/li&gt;
&lt;li&gt;Queue: 存储并接受Exchange分发的消息, 用于Consumer接受消息&lt;/li&gt;
&lt;li&gt;Routing Key: 标识Message, 用于Exchange分发消息的依据&lt;/li&gt;
&lt;li&gt;Binding: Queue与Exchange绑定, 可选的binding key参数用于指定特定的消息(相当于消息的routing key)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;在RabbitMQ中, 消息是发送给&lt;code&gt;Exchange&lt;/code&gt;的, 而不是&lt;code&gt;Queue&lt;/code&gt;, &lt;code&gt;Producer&lt;/code&gt;将带有&lt;code&gt;Routing Key&lt;/code&gt;的消息发送给相应的
&lt;code&gt;Exchange&lt;/code&gt;后, 整个消息的发送过程就结束了; 消息的接收是通过&lt;code&gt;Queue&lt;/code&gt;完成的, &lt;code&gt;Consumer&lt;/code&gt;在RabbitMQ中定义
一个&lt;code&gt;Queue&lt;/code&gt;, 与相应的&lt;code&gt;Exchange&lt;/code&gt;进行&lt;code&gt;Binding&lt;/code&gt;, 在&lt;code&gt;Binding&lt;/code&gt;时可指定感兴趣的消息, 通过&lt;code&gt;binding key&lt;/code&gt;来完成,这
样消息就会被&lt;code&gt;Exchange&lt;/code&gt;根据&lt;code&gt;binding key&lt;/code&gt;分发到相应的&lt;code&gt;Queue&lt;/code&gt;上,  &lt;code&gt;Consumer&lt;/code&gt;接受&lt;code&gt;Queue&lt;/code&gt;的消息即可,
这样整个消息的接收就完成了.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/python-three-overall.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示, &lt;code&gt;P&lt;/code&gt;代表&lt;code&gt;Producer&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;代表&lt;code&gt;Exchange&lt;/code&gt;, 红色的代表&lt;code&gt;Queue&lt;/code&gt;以及相应的queue name, binding表示上
述的&lt;code&gt;Binding&lt;/code&gt;过程, &lt;code&gt;C&lt;/code&gt;代表&lt;code&gt;Consumer&lt;/code&gt;.&lt;/p&gt;

&lt;h4&gt;RabbitMQ中的Exchange&lt;/h4&gt;

&lt;p&gt;Exchange在RabbitMQ中也有相应的分类:&lt;code&gt;Direct&lt;/code&gt; &lt;code&gt;Fanout&lt;/code&gt; &lt;code&gt;Topic&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Exchange的分类是为了实现不同的通信模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Fanout: 消息将分发给所有与&lt;code&gt;Exchange&lt;/code&gt;绑定的&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Direct: 消息将通过 &lt;em&gt;完全匹配&lt;/em&gt; &lt;code&gt;Routing Key&lt;/code&gt;分发到相应的&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Topic: 消息将通过 &lt;em&gt;正则匹配(支持特殊字符)&lt;/em&gt; &lt;code&gt;Routing Key&lt;/code&gt;分发到相应的&lt;code&gt;Queue&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;因此, 当使用&lt;code&gt;Fanout&lt;/code&gt;类型的&lt;code&gt;Exchange&lt;/code&gt;, 消息将分发至所有与该&lt;code&gt;Exchange&lt;/code&gt;绑定的&lt;code&gt;Queue&lt;/code&gt;上, 此时不会匹配&lt;code&gt;Routing Key&lt;/code&gt;,
当使用&lt;code&gt;Direct&lt;/code&gt;类型的&lt;code&gt;Exchange&lt;/code&gt;, 消息将通过&lt;em&gt;完全匹配&lt;/em&gt;(&lt;code&gt;Routing Key&lt;/code&gt;与&lt;code&gt;Binding Key&lt;/code&gt;)被分发至相应的&lt;code&gt;Queue&lt;/code&gt;, 同理,
&lt;code&gt;Topic&lt;/code&gt;类型的&lt;code&gt;Exchange&lt;/code&gt;会进行&lt;em&gt;正则匹配&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;如图, &lt;code&gt;Direct Exchange&lt;/code&gt;类型的消息模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/direct-exchange.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图, &lt;code&gt;Topic Exchange&lt;/code&gt;类型的消息模型:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://www.rabbitmq.com/img/tutorials/python-five.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从两种类型的&lt;code&gt;Exchange&lt;/code&gt;可以看出, 区别仅在于分发消息时对于&lt;code&gt;Routing Key&lt;/code&gt;的匹配方式, &lt;code&gt;Direct&lt;/code&gt;是&lt;em&gt;完全匹配&lt;/em&gt;&lt;code&gt;Queue&lt;/code&gt;的&lt;code&gt;Binding Key&lt;/code&gt;,
&lt;code&gt;Topic&lt;/code&gt;则是使用&lt;em&gt;正则匹配&lt;/em&gt;.&lt;/p&gt;

&lt;h3&gt;Openstack RPC&lt;/h3&gt;

&lt;p&gt;在Openstack中, 组件内的通信主要通过消息队列完成, 这样可以使整个系统以松耦合的方式进行协作, 以RabbitMQ为例,
Openstack实现了组件间的RPC调用, 主要包括&lt;em&gt;同步&lt;/em&gt;和&lt;em&gt;异步&lt;/em&gt;两种调用方式:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;python&quot;&gt;    &quot;&quot;&quot;oslo/messaging/rpc/client.py&quot;&quot;&quot;
    class RPCClient(object):

        &quot;&quot;&quot;A class for invoking methods on remote servers.
        The RPCClient class is responsible for sending method invocations to remote
        servers via a messaging transport.

        A cast() invocation just sends the request and returns immediately. 
        A call() invocation waits for the server to send a return value.
        &quot;&quot;&quot;

        def cast(self, ctxt, method, **kwargs):
            &quot;&quot;&quot;Invoke a method and return immediately.
            &quot;&quot;&quot;
            self.prepare().cast(ctxt, method, **kwargs)
        def call(self, ctxt, method, **kwargs):
            &quot;&quot;&quot;Invoke a method and wait for a reply.
            &quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;插入的代码只是RPCClient实现的一部分, 从注释可以看出, &lt;code&gt;cast函数&lt;/code&gt;属于异步调用, &lt;code&gt;call函数&lt;/code&gt;属于同步调用.&lt;/p&gt;

&lt;h4&gt;cast实现方式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://docs.openstack.org/developer/nova/_images/flow2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;rpc调用方会初始化&lt;code&gt;Topic Publisher&lt;/code&gt;, 将消息以&lt;code&gt;Routing Key&lt;/code&gt;为topic发送至配置的&lt;code&gt;Exchange&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;&lt;p&gt;rpc接收方会初始化两个&lt;code&gt;Topic Cosumer&lt;/code&gt;, 分别通过topic和topic.host为&lt;code&gt;binding key&lt;/code&gt;将&lt;code&gt;Queue&lt;/code&gt;与&lt;code&gt;Exchange&lt;/code&gt;绑定,
这样接收方就可以接收这两种类型的rpc message&lt;/p&gt;

&lt;p&gt;  &lt;code&gt;topic&lt;/code&gt;即为消息的&lt;code&gt;Routing Key&lt;/code&gt;, 所以接收方可以接受到调用方的rpc message.&lt;br&gt;
  &lt;code&gt;topic.host&lt;/code&gt;为特定的host上的接收方获取rpc message的方式, 例如: l3-agent.host1(通知host1上的l3-agent进行相关rpc调用)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;call实现方式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;http://docs.openstack.org/developer/nova/_images/flow1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;rpc调用方初始化&lt;code&gt;Topic Publisher&lt;/code&gt;用于发送rpc message, 同时初始化一个&lt;code&gt;Direct Consumer&lt;/code&gt;用于接收返回的rpc调用结果,
为了保证收到相应的rpc调用的结果, rpc message中会保存一个唯一标识该消息的messga id(UUID类型), 消息以&lt;code&gt;Routing Key&lt;/code&gt;为topic发送至
&lt;code&gt;Exchange&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;rpc接收方会初始化两个&lt;code&gt;Topic Cosumer&lt;/code&gt;, 分别通过topic和topic.host为&lt;code&gt;binding key&lt;/code&gt;将&lt;code&gt;Queue&lt;/code&gt;与&lt;code&gt;Exchange&lt;/code&gt;绑定, rpc
接收方执行rpc调用, 完成后通过&lt;code&gt;Direct Publisher&lt;/code&gt;将结果发送到消息队列中, 返回的执行结果message的&lt;code&gt;Routing Key&lt;/code&gt;为message id
(唯一的UUID), 将被发送至&lt;code&gt;Exchange&lt;/code&gt;(名称同样是唯一的message id), 那样调用方的&lt;code&gt;Direct Consumer&lt;/code&gt;就可以收到rpc调用的结果了.&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;以ovs_neutron_agent为例理解rpc的实现&lt;/h4&gt;

&lt;p&gt;在ovs_neutron_agent的代码中, rpc的初始化如下:
~~~python
    &quot;&quot;&quot;plugins/openvswitch/agent/ovs_neutron_agent.py&quot;&quot;&quot;
    def setup_rpc(self):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ......
    #作为rpc调用方的初始化
    self.plugin_rpc = OVSPluginApi(topics.PLUGIN)   #与ml2 plgin通信
    self.state_rpc = agent_rpc.PluginReportStateAPI(topics.PLUGIN)

    #作为rpc接收方的初始化
    self.topic = topics.AGENT
    # Handle updates from service
    self.endpoints = [self]
    # Define the listening consumers for the agent
    consumers = [[topics.PORT, topics.UPDATE],
                 [topics.NETWORK, topics.DELETE],
                 [constants.TUNNEL, topics.UPDATE],
                 [topics.SECURITY_GROUP, topics.UPDATE],
                 [topics.DVR, topics.UPDATE]]
    if self.l2_pop:
        consumers.append([topics.L2POPULATION,
                          topics.UPDATE, cfg.CONF.host])
    self.connection = agent_rpc.create_consumers(self.endpoints,
                                                 self.topic,
                                                 consumers)
    ......
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
self.topic为ovs_neutron_agent会接收的rpc message的类型前缀, 在topics.py中定义:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;common/topics.py&quot;&quot;&quot;
AGENT = &#39;q-agent-notifier&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;在neutron中, 消息可以分为不同的类型, 以AGENT=&#39;q-agent-notifier&#39;为例, 表示为通知agent端的消息类型.

self.consumers为ovs_neutron_agent会接收的rpc message的具体类型, 在agent_rpc.create_consumers()函数中, 完成了consumers的初始化:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot;agent/rpc.py&quot;&quot;&quot;
def create_consumers(endpoints, prefix, topic_details):
    &quot;&quot;&quot;
    :param endpoints: The list of endpoints to process the incoming messages.
    :param prefix: Common prefix for the plugin/agent message queues.
    :param topic_details: A list of topics. Each topic has a name, an
                          operation, and an optional host param keying the
                          subscription to topic.host for plugin calls.
    &quot;&quot;&quot;

    connection = n_rpc.create_connection(new=True)
    for details in topic_details:
        topic, operation, node_name = itertools.islice(
            itertools.chain(details, [None]), 3)

        topic_name = topics.get_topic_name(prefix, topic, operation)
        connection.create_consumer(topic_name, endpoints, fanout=True)
        if node_name: #node_name即为host name
            node_topic_name = &#39;%s.%s&#39; % (topic_name, node_name)
            connection.create_consumer(node_topic_name,
                                       endpoints,
                                       fanout=False)
    connection.consume_in_threads()
    return connection
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
这里需要关注的就是create\_consumer函数, 以及传递给该函数的参数topic_name, endpoints, 对于fanout参数, 当
host存在时, 就不需要fanout类型, 因为只需要特定的host接收. topic\_name为prefix + topic + operation, 例如:
`q-agent-notifier-port-update`, `q-agent-notifier-port-update.hostname`, `q-agent-notifier-security_grout-update`等, 
这些例子就会作为topic_name传递给create_consumer函数, endpoints为执行rpc函数的载体, 此处应该传递的:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    self.endpoints = [self]  #上面的setup_rpc函数中, 即为实例本身
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def get_server(target, endpoints, serializer=None):
    assert TRANSPORT is not None
    serializer = RequestContextSerializer(serializer)
    return messaging.get_rpc_server(TRANSPORT, target, endpoints,
                                    &#39;eventlet&#39;, serializer)

class Connection(object):

    def __init__(self):
        super(Connection, self).__init__()
        self.servers = []

    def create_consumer(self, topic, endpoints, fanout=False):
        target = messaging.Target(
            topic=topic, server=cfg.CONF.host, fanout=fanout)
        server = get_server(target, endpoints)
        self.servers.append(server)

    def consume_in_threads(self):
        for server in self.servers:
            server.start()
        return self.servers

# functions
def create_connection(new=True):
    return Connection()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在create_consumer函数中, 首先初始化target, 其作用是封装了关于rpc message相关联的属性, 
比如该消息发送到的`Exchange`, 消息的topic(Routing Key)等.

&amp;gt; 注意: 在neutron中, 消息的topic其实就是消息发送进`Exchange`所带有的`Routing Key`, 比如以topic `q-agent-notifier-port-update`
&amp;gt; 为例, 与port-update相关的rpc message应该都是`Routing Key`为`q-agent-notifier-port-update`的.

然后在get_server函数中, serializer为序列化rpc消息的函数, 用于将raw rpc message序列化为适合neutron上下文的dict, 可以不用
深入去看, 明白其含义即可, TRANSPORT为消息的传递载体, 因为openstack中可以使用rabbitmq, 以及zeromq等消息队列, TRANSPOST主要
完成了对相应消息队列功能的封装, 这儿以rabbitmq为消息队列, 也就是说, 消息是通过TRANSPORT(rabbimq)传递的.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def get_rpc_server(transport, target, endpoints,
                   executor=&#39;blocking&#39;, serializer=None):
    &quot;&quot;&quot;Construct an RPC server.

    The executor parameter controls how incoming messages will be received and
    dispatched. By default, the most simple executor is used - the blocking
    executor.

    :param transport: the messaging transport
    :type transport: Transport
    :param target: the exchange, topic and server to listen on
    :type target: Target
    :param endpoints: a list of endpoint objects
    :type endpoints: list
    :param executor: name of a message executor - for example
                     &#39;eventlet&#39;, &#39;blocking&#39;
    :type executor: str
    :param serializer: an optional entity serializer
    :type serializer: Serializer
    &quot;&quot;&quot;
    dispatcher = rpc_dispatcher.RPCDispatcher(target, endpoints, serializer)
    return msg_server.MessageHandlingServer(transport, dispatcher, executor)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在messaging.get_rpc_server函数中, 进行了dispatcher的初始化, 它的主要作用为从TRANSPORT中接受感兴趣的消息, 
而target描述了这些感兴趣的消息的属性, target记录了这些信息.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class MessageHandlingServer(object):
    &quot;&quot;&quot;Server for handling messages.

    Connect a transport to a dispatcher that knows how to process the
    message using an executor that knows how the app wants to create
    new tasks.
    &quot;&quot;&quot;

    def __init__(self, transport, dispatcher, executor=&#39;blocking&#39;):
        &quot;&quot;&quot;Construct a message handling server.

        The dispatcher parameter is a callable which is invoked with context
        and message dictionaries each time a message is received.

        The executor parameter controls how incoming messages will be received
        and dispatched. By default, the most simple executor is used - the
        blocking executor.

        :param transport: the messaging transport
        :type transport: Transport
        :param dispatcher: a callable which is invoked for each method
        :type dispatcher: callable
        :param executor: name of message executor - for example
                         &#39;eventlet&#39;, &#39;blocking&#39;
        :type executor: str
        &quot;&quot;&quot;
        self.conf = transport.conf

        self.transport = transport
        self.dispatcher = dispatcher
        self.executor = executor

        try:
            mgr = driver.DriverManager(&#39;oslo.messaging.executors&#39;,
                                       self.executor)
        except RuntimeError as ex:
            raise ExecutorLoadFailure(self.executor, ex)
        else:
            self._executor_cls = mgr.driver
            self._executor = None

        super(MessageHandlingServer, self).__init__()

    def start(self):
        &quot;&quot;&quot;Start handling incoming messages.
        &quot;&quot;&quot;
        if self._executor is not None:
            return
        try:
            listener = self.dispatcher._listen(self.transport)
        except driver_base.TransportDriverError as ex:
            raise ServerListenError(self.target, ex)

        self._executor = self._executor_cls(self.conf, listener,
                                            self.dispatcher)
        self._executor.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
接下来在MessageHandlingServer(transport, dispatcher, executor)中, executor为&#39;blocking&#39;, 表示rpc函数的执行会
阻塞当前线程, 相应的参数还有&#39;eventlet&#39;, 表示在新的eventlet线程中执行, 我们也不需要关心这部分内容, 但是
需要明白其作用. 在上面的start函数中, listener为dispatcher的_listen所返回的结果, 从listener中, 我们就可以
接收到一个一个的消息了, 然后通过self._executor.start(), 开始获取消息并进行相应的rpc调用.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;def spawn_with(ctxt, pool):
    &quot;&quot;&quot;This is the equivalent of a with statement
    but with the content of the BLOCK statement executed
    into a greenthread

    exception path grab from:
    http://www.python.org/dev/peps/pep-0343/
    &quot;&quot;&quot;

    def complete(thread, exit):
        exc = True
        try:
            try:
                thread.wait()
            except Exception:
                exc = False
                if not exit(*sys.exc_info()):
                    raise
        finally:
            if exc:
                exit(None, None, None)

    callback = ctxt.__enter__()
    thread = pool.spawn(callback)
    thread.link(complete, ctxt.__exit__)

    return thread

class EventletExecutor(base.ExecutorBase):

    &quot;&quot;&quot;A message executor which integrates with eventlet.

    This is an executor which polls for incoming messages from a greenthread
    and dispatches each message in its own greenthread.

    The stop() method kills the message polling greenthread and the wait()
    method waits for all message dispatch greenthreads to complete.
    &quot;&quot;&quot;

    def __init__(self, conf, listener, dispatcher):
        super(EventletExecutor, self).__init__(conf, listener, dispatcher)
        self.conf.register_opts(_eventlet_opts)
        self._thread = None
        self._greenpool = greenpool.GreenPool(self.conf.rpc_thread_pool_size)
        self._running = False

    def start(self):
        if self._thread is not None:
            return

        @excutils.forever_retry_uncaught_exceptions
        def _executor_thread():
            try:
                while self._running:
                    incoming = self.listener.poll(timeout=base.POLL_TIMEOUT)
                    if incoming is not None:
                        spawn_with(ctxt=self.dispatcher(incoming),
                                   pool=self._greenpool)
            except greenlet.GreenletExit:
                return

        self._running = True
        self._thread = eventlet.spawn(_executor_thread)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在self.\_executor的实现中, start函数的self.listener.poll()函数不断获取rpc消息, 并将新消息在新的eventlet thread中执行, 其中spwan_with中会产生
新的thread, 同时传递给spwan\_with的参数为ctxt=self.dispatcher(incoming), 需要特别注意, 因为dispatcher实现了[\_\_call\_\_][1]方法, 由于
self.dispatcher是一个可调用对象, 因此ctxt=self.dispatcher(incoming)这样的调用是可行的.

现在我们就可以看看在dispatcher中, 消息是怎样得到处理的.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class RPCDispatcher(object):
    &quot;&quot;&quot;A message dispatcher which understands RPC messages.

    A MessageHandlingServer is constructed by passing a callable dispatcher
    which is invoked with context and message dictionaries each time a message
    is received.

    RPCDispatcher is one such dispatcher which understands the format of RPC
    messages. The dispatcher looks at the namespace, version and method values
    in the message and matches those against a list of available endpoints.

    Endpoints may have a target attribute describing the namespace and version
    of the methods exposed by that object. All public methods on an endpoint
    object are remotely invokable by clients.
    &quot;&quot;&quot;

    def __init__(self, target, endpoints, serializer):
        &quot;&quot;&quot;Construct a rpc server dispatcher.

        :param target: the exchange, topic and server to listen on
        :type target: Target
        &quot;&quot;&quot;

        self.endpoints = endpoints
        self.serializer = serializer or msg_serializer.NoOpSerializer()
        self._default_target = msg_target.Target()
        self._target = target

    def _listen(self, transport):
        return transport._listen(self._target)

    @staticmethod
    def _is_namespace(target, namespace):
        return namespace == target.namespace

    @staticmethod
    def _is_compatible(target, version):
        endpoint_version = target.version or &#39;1.0&#39;
        return utils.version_is_compatible(endpoint_version, version)

    def _do_dispatch(self, endpoint, method, ctxt, args):
        ctxt = self.serializer.deserialize_context(ctxt)
        new_args = dict()
        for argname, arg in six.iteritems(args):
            new_args[argname] = self.serializer.deserialize_entity(ctxt, arg)
        result = getattr(endpoint, method)(ctxt, **new_args)
        return self.serializer.serialize_entity(ctxt, result)

    @contextlib.contextmanager
    def __call__(self, incoming):
        incoming.acknowledge()
        yield lambda: self._dispatch_and_reply(incoming)

    def _dispatch_and_reply(self, incoming):
        try:
            incoming.reply(self._dispatch(incoming.ctxt,
                                          incoming.message))
        except ExpectedException as e:
            LOG.debug(u&#39;Expected exception during message handling (%s)&#39;,
                      e.exc_info[1])
            incoming.reply(failure=e.exc_info, log_failure=False)
        except Exception as e:
            # sys.exc_info() is deleted by LOG.exception().
            exc_info = sys.exc_info()
            LOG.error(_(&#39;Exception during message handling: %s&#39;), e,
                      exc_info=exc_info)
            incoming.reply(failure=exc_info)
            # NOTE(dhellmann): Remove circular object reference
            # between the current stack frame and the traceback in
            # exc_info.
            del exc_info

    def _dispatch(self, ctxt, message):
        &quot;&quot;&quot;Dispatch an RPC message to the appropriate endpoint method.

        :param ctxt: the request context
        :type ctxt: dict
        :param message: the message payload
        :type message: dict
        :raises: NoSuchMethod, UnsupportedVersion
        &quot;&quot;&quot;
        method = message.get(&#39;method&#39;)
        args = message.get(&#39;args&#39;, {})
        namespace = message.get(&#39;namespace&#39;)
        version = message.get(&#39;version&#39;, &#39;1.0&#39;)

        found_compatible = False
        for endpoint in self.endpoints:
            target = getattr(endpoint, &#39;target&#39;, None)
            if not target:
                target = self._default_target

            if not (self._is_namespace(target, namespace) and
                    self._is_compatible(target, version)):
                continue

            if hasattr(endpoint, method): #从endpoint中获取相应的rpc method
                localcontext.set_local_context(ctxt) #执行rpc调用
                try:
                    return self._do_dispatch(endpoint, method, ctxt, args) #返回序列化的结果
                finally:
                    localcontext.clear_local_context()

            found_compatible = True

        if found_compatible:
            raise NoSuchMethod(method)
        else:
            raise UnsupportedVersion(version, method=method)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在\_\_call\_\_方法中, 返回的[lambda][2]即为: self._dispatch_and_reply(incoming), 然后消息会在\_dispatch函数中被处理并返回相应的
rpc调用的结果.

#### Transport如何通过Target获取相应的消息
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;    def _listen(self, transport):
        return transport._listen(self._target)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
在上面dispatcher的实现中, 可以看到_listen函数是通过tranport.\_listen实现的, 并相应的传递了self._target作为参数.
因此, 我们可以通过理解Transport的实现来理解openstack neutron中topic的含义.
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class Transport(object):
    &quot;&quot;&quot;A messaging transport.
    This is a mostly opaque handle for an underlying messaging transport
    driver.
    It has a single &#39;conf&#39; property which is the cfg.ConfigOpts instance used
    to construct the transport object.
    &quot;&quot;&quot;
    def __init__(self, driver):
        self.conf = driver.conf
        self._driver = driver

    def _send(self, target, ctxt, message, wait_for_reply=None, timeout=None,
              retry=None):
        if not target.topic:
            raise exceptions.InvalidTarget(&#39;A topic is required to send&#39;,
                                           target)
        return self._driver.send(target, ctxt, message,
                                 wait_for_reply=wait_for_reply,
                                 timeout=timeout, retry=retry)

    def _send_notification(self, target, ctxt, message, version, retry=None):
        if not target.topic:
            raise exceptions.InvalidTarget(&#39;A topic is required to send&#39;,
                                           target)
        self._driver.send_notification(target, ctxt, message, version,
                                       retry=retry)

    def _listen(self, target):
        if not (target.topic and target.server):
            raise exceptions.InvalidTarget(&#39;A server\&#39;s target must have &#39;
                                           &#39;topic and server names specified&#39;,
                                           target)
        return self._driver.listen(target) #相应的实现在driver中实现
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;
可以看到, 不同的transport都实现了listen函数, 以rabbitmq的实现为例, driver代码如下:
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;class AMQPDriverBase(base.BaseDriver):

    def __init__(self, conf, url, connection_pool,
                 default_exchange=None, allowed_remote_exmods=None):
        super(AMQPDriverBase, self).__init__(conf, url, default_exchange,
                                             allowed_remote_exmods)

        self._default_exchange = default_exchange

        self._connection_pool = connection_pool

        self._reply_q_lock = threading.Lock()
        self._reply_q = None
        self._reply_q_conn = None
        self._waiter = None

    def _get_exchange(self, target):
        return target.exchange or self._default_exchange

    def _get_connection(self, pooled=True):
        return rpc_amqp.ConnectionContext(self._connection_pool,
                                          pooled=pooled)

    def _get_reply_q(self):
        with self._reply_q_lock:
            if self._reply_q is not None:
                return self._reply_q

            reply_q = &#39;reply_&#39; + uuid.uuid4().hex

            conn = self._get_connection(pooled=False)

            self._waiter = ReplyWaiter(self.conf, reply_q, conn,
                                       self._allowed_remote_exmods)

            self._reply_q = reply_q
            self._reply_q_conn = conn

        return self._reply_q

    def _send(self, target, ctxt, message,
              wait_for_reply=None, timeout=None,
              envelope=True, notify=False, retry=None):

        # FIXME(markmc): remove this temporary hack
        class Context(object):
            def __init__(self, d):
                self.d = d

            def to_dict(self):
                return self.d

        context = Context(ctxt)
        msg = message

        if wait_for_reply:
            msg_id = uuid.uuid4().hex
            msg.update({&#39;_msg_id&#39;: msg_id})
            LOG.debug(&#39;MSG_ID is %s&#39;, msg_id)
            msg.update({&#39;_reply_q&#39;: self._get_reply_q()})

        rpc_amqp._add_unique_id(msg)
        rpc_amqp.pack_context(msg, context)

        if envelope:
            msg = rpc_common.serialize_msg(msg)

        if wait_for_reply:
            self._waiter.listen(msg_id)

        try:
            with self._get_connection() as conn:
                if notify:
                    conn.notify_send(self._get_exchange(target),
                                     target.topic, msg, retry=retry)
                elif target.fanout:
                    conn.fanout_send(target.topic, msg, retry=retry)
                else:
                    topic = target.topic
                    if target.server:
                        topic = &#39;%s.%s&#39; % (target.topic, target.server)
                    conn.topic_send(exchange_name=self._get_exchange(target),
                                    topic=topic, msg=msg, timeout=timeout,
                                    retry=retry)

            if wait_for_reply:
                result = self._waiter.wait(msg_id, timeout)
                if isinstance(result, Exception):
                    raise result
                return result
        finally:
            if wait_for_reply:
                self._waiter.unlisten(msg_id)

    def send(self, target, ctxt, message, wait_for_reply=None, timeout=None,
             retry=None):
        return self._send(target, ctxt, message, wait_for_reply, timeout,
                          retry=retry)

    def send_notification(self, target, ctxt, message, version, retry=None):
        return self._send(target, ctxt, message,
                          envelope=(version == 2.0), notify=True, retry=retry)

    def listen(self, target):
        conn = self._get_connection(pooled=False)

        listener = AMQPListener(self, conn)

        conn.declare_topic_consumer(exchange_name=self._get_exchange(target), #定义Topic Consumer
                                    topic=target.topic,
                                    callback=listener)
        conn.declare_topic_consumer(exchange_name=self._get_exchange(target),
                                    topic=&#39;%s.%s&#39; % (target.topic,
                                                     target.server),
                                    callback=listener)
        conn.declare_fanout_consumer(target.topic, listener)

        return listener

    def listen_for_notifications(self, targets_and_priorities, pool):
        conn = self._get_connection(pooled=False)

        listener = AMQPListener(self, conn)
        for target, priority in targets_and_priorities:
            conn.declare_topic_consumer(
                exchange_name=self._get_exchange(target),
                topic=&#39;%s.%s&#39; % (target.topic, priority),
                callback=listener, queue_name=pool)
        return listener
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;~~~&lt;/p&gt;

&lt;p&gt;从上面listen的代码, 就回到了rpc call和rpc cast模型, 定义Topic Consumer, 但是为什么会初始化3个&lt;code&gt;Consumer&lt;/code&gt;呢？&lt;/p&gt;

&lt;p&gt;这要从rpc方法调用的方式说起, rpc call和 rpc cast有两种方式: topic + topic.host, rpc fanout_cast有一种方式: fanout, 所以对应的&lt;code&gt;Consumer&lt;/code&gt;
也有3种, 因为在消息的接收方看来, 我不需要关心消息是以什么方式传输过来的, 无论是rpc call, 或者rpc cast, 或rpc fanout_cast, 对于
消息本身才是它需要关心的, 因此它可以接收三种方式发送过来的消息, 所以会初始化3种&lt;code&gt;Consumer&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;总结&lt;/h3&gt;

&lt;p&gt;结合RabbbitMQ的基本概念, 不难看出, openstack中与rpc调用相关的topic, 对消息发送方(rpc调用方)来说, 它就是
消息的&lt;code&gt;Routing Key&lt;/code&gt;, 对于消息接收方(rpc接受方), 它就是初始化&lt;code&gt;Consumer&lt;/code&gt;时用于接受消息的&lt;code&gt;Queue&lt;/code&gt;的名称,
且&lt;code&gt;Queue&lt;/code&gt;与&lt;code&gt;Exchange&lt;/code&gt;的Binding Key也为它.&lt;/p&gt;

&lt;h3&gt;参考网站&lt;/h3&gt;

&lt;p&gt;RabbitMQ:   &lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;http://www.rabbitmq.com/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 
</feed>
